---
title: "2022 11 05_C++_PRIMER"
slug: ""
date: 2022-11-05T12:50:16+08:00
summary: ""
author: ["Jian"]
cover:
    image: ""
    alt: ""
tags: []
katex: true
mermaid: false
draft: false
---

## 

### 2.4

#### 2.4.2 指针和const

**const指针**

<u>常量指针(const pointer)</u>: 必须初始化，存放在指针中的<font color=red>地址的值不能改变</font>

```c++
int *const curRrr = &errNumb;
const double *const pip = &pi;
```

#### 2.4.2 顶层const

顶层const(top-level const): 指针本身是个常量(指针不可改变，地址不可改变, 仅仅对指针有效)

```c++
int * const p = & errNumb;
const int p = 42;
```
底层const(low-level const): 指针所指的对象是一个常量(对象的值不可改变)

```c++
const int *p = & errNumb;
int const *p = & errNumb;
```

#### 2.4.4 constexpr 和 常量表达式

常量表达式(const expression) 是指值不会改变并且在**编译过程**就能得到计算结果的表达式。

**constexpr变量**
C++11新标准规定，允许将变量声名为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。

**指针和constexpr**

在constexpr声名中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

### 2.5 处理类型

#### 2.5.1 类型别名
`typedef`

`using`


指针、常量和类型别名

```
typedef char *pstring;
const pstring cstr = 0; //声明指向char的常量指针，其基本数据类型是指针
const char *cstr = 0; // 声明指向常量字符的指针，其基本数据类型是char
```


#### 2.5.2 auto 类型说明符

(c++11) `auto:` 让编译器通过初始值去分析表达式的所属类型。


复合类型、常量和auto

1. 以引用对象的类型作为初始值; 或者将引用的类型设为auto, `auto &g = ci`
2. auto一般会忽略顶层const， 底层const则会保留; 顶层const需要明确指出，例如`auto const f = ci`

<font color=red>符号&和*只是从属于某个声名符，而非基本数据类型的一部分</font>

#### 2.5.3 decltype类型指示符

(c++11)

类型说明符`decltype`: 选择并返回操作数的类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
```c++
// sum的类型就是调用函数f() 返回的类型
delcltype(f()) sum = x; 
```

> decltype处理顶层const和引用的方式和auto不同。如果decltype使用的表达式是一个变量，则decltype返回该变量类型(包括顶层const和引用)

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; //x的类型是const int
decltype(cj) y = x; // y的类型是const int &, y绑定到变量x
decltype(cj) z; //错误: z 是一个引用，必须初始化 
```

decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

```c++
// decltype 可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r) z; //错误: z的类型是int&, 必须初始化
decltype(r + 0) b; // 正确， int
decltype(*p) c; //错误: c的类型是int&, 必须初始化
```

> 如果表达式的内容是解引用, 则decltype将得到引用类型。

### 2.6 自定义数据结构

#### 2.6.1

类数据成员

(c++11)可以为数据成员提供<u>类内初始值</u>

#### 2.6.2 使用sales_data类
#### 2.6.3 编写自己的头文件

预处理器概述

`#include:`用指定文件代替#include
`#define:`把一个名字设定为预处理变量
`#ifdef:`当且仅当变量已定义时为真
`#ifndef:`当且仅当变量未定义时为真
`#endif:`一旦检查结果为真，则执行后续操作直到#endif指令为止


## chapter 3 字符串、向量和数组
### 3.1 命名空间的using声明
作用域操作符`::`:编译器从操作符左侧名字所示的作用域中寻找右侧那个名字。

使用using声明: `using namespace::name;`

每个名字都需要独立的using声明。
头文件不应包含using声明，因为头文件会拷贝到所有引用它的文件中去，容易引起名字冲突。

### 3.2 标准库类型string

#### 2.2.2
####
####
####
####

