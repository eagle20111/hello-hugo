---
title: "2022 11 05_C++_PRIMER"
slug: ""
date: 2022-11-05T12:50:16+08:00
summary: ""
author: ["Jian"]
cover:
    image: ""
    alt: ""
tags: []
katex: true
mermaid: false
draft: false
---

## 

### 2.4

#### 2.4.2 指针和const

**const指针**

<u>常量指针(const pointer)</u>: 必须初始化，存放在指针中的<font color=red>地址的值不能改变</font>

```c++
int *const curRrr = &errNumb;
const double *const pip = &pi;
```

#### 2.4.2 顶层const

顶层const(top-level const): 指针本身是个常量(指针不可改变，地址不可改变, 仅仅对指针有效)

```c++
int * const p = & errNumb;
const int p = 42;
```
底层const(low-level const): 指针所指的对象是一个常量(对象的值不可改变)

```c++
const int *p = & errNumb;
int const *p = & errNumb;
```

#### 2.4.4 constexpr 和 常量表达式

常量表达式(const expression) 是指值不会改变并且在**编译过程**就能得到计算结果的表达式。

**constexpr变量**
C++11新标准规定，允许将变量声名为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。

**指针和constexpr**

在constexpr声名中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

### 2.5 处理类型

#### 2.5.1 类型别名
`typedef`

`using`


指针、常量和类型别名

```
typedef char *pstring;
const pstring cstr = 0; //声明指向char的常量指针，其基本数据类型是指针
const char *cstr = 0; // 声明指向常量字符的指针，其基本数据类型是char
```


#### 2.5.2 auto 类型说明符

(c++11) `auto:` 让编译器通过初始值去分析表达式的所属类型。


复合类型、常量和auto

1. 以引用对象的类型作为初始值; 或者将引用的类型设为auto, `auto &g = ci`
2. auto一般会忽略顶层const， 底层const则会保留; 顶层const需要明确指出，例如`auto const f = ci`

<font color=red>符号&和*只是从属于某个声名符，而非基本数据类型的一部分</font>

#### 2.5.3 decltype类型指示符

(c++11)

类型说明符`decltype`: 选择并返回操作数的类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
```c++
// sum的类型就是调用函数f() 返回的类型
delcltype(f()) sum = x; 
```

> decltype处理顶层const和引用的方式和auto不同。如果decltype使用的表达式是一个变量，则decltype返回该变量类型(包括顶层const和引用)

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; //x的类型是const int
decltype(cj) y = x; // y的类型是const int &, y绑定到变量x
decltype(cj) z; //错误: z 是一个引用，必须初始化 
```

decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

```c++
// decltype 可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r) z; //错误: z的类型是int&, 必须初始化
decltype(r + 0) b; // 正确， int
decltype(*p) c; //错误: c的类型是int&, 必须初始化
```

> 如果表达式的内容是解引用, 则decltype将得到引用类型。

### 2.6 自定义数据结构

#### 2.6.1

类数据成员

(c++11)可以为数据成员提供<u>类内初始值</u>

#### 2.6.2 使用sales_data类
#### 2.6.3 编写自己的头文件

预处理器概述

`#include:`用指定文件代替#include
`#define:`把一个名字设定为预处理变量
`#ifdef:`当且仅当变量已定义时为真
`#ifndef:`当且仅当变量未定义时为真
`#endif:`一旦检查结果为真，则执行后续操作直到#endif指令为止


## chapter 3 字符串、向量和数组
### 3.1 命名空间的using声明
作用域操作符`::`:编译器从操作符左侧名字所示的作用域中寻找右侧那个名字。

使用using声明: `using namespace::name;`

每个名字都需要独立的using声明。
头文件不应包含using声明，因为头文件会拷贝到所有引用它的文件中去，容易引起名字冲突。

### 3.2 标准库类型string

#### 3.2.1 定义和初始化string对象

**概念区分:** 直接初始化和拷贝初始化

拷贝初始化：使用`=`初始化一个变量，编译器直接把等号右侧的初始值拷贝到新创建的变量中去。
直接初始化： 不适用等号进行初始化

#### 3.2.2 string对象上的一些操作

读写string对象
  - 可以使用iostream读写string对象
  - 读取位置数量的string对象
    ```c++
    int main() {
        string word;
        while (cin >> word) {
            cout << word << endl;
        }
        return 0;
    }
    ```
  - 使用getline读取一整行: getline函数传入一个输入流和一个string对象，读取输入流直到遇到换行符，换行符也被读取进来，但是不存到string对象中
    ```c++
    int main() {
        string line;
        while (getline(cin, line)) {
            cout << line << endl;
        }
        return 0;
    }
    ```
  - string的`empty()`和`size()`操作
  - string::size_type类型： 一个无符号类型的值
  - 比较string对象：`==`、`!=`、`<`、`<=`、`>`、`>=`(比较大小按字典顺序)
  - 为string对象赋值
  - 两个string对象相加
  - 字面值和string对象相加：加法两面必须有一个是string对象
  ```c++
  string s1 = "hello";
  string s6 = s1 + ", " + "world"; // 正确: s1 + ", " 返回一个string对象
  string s7 = "hello" + "world"; // 错误: 加号码两边都是字面值，没有string对象
  ```

#### 3.2.3 处理string对象中的字符

  - 处理每个字符? 使用基于for循环：`for (char ch : string)`
  - 使用for循环改变字符串中的字符，必须把循环变量定义成引用类型：`for (auto& ch : string)`
  - 只处理一部分字符： 使用下标或索引
    - 使用下标执行迭代：
    - 使用下标执行随机访问：

### 3.3 标准库类型vector

### 3.4 迭代器介绍

#### 3.4.1 使用迭代器

  - begin() 和 end()
    - (c++11) const_iterator: cbegin() 和 cend();
  - 迭代器运算符:
    - `==` 和 `!=`：比较两个迭代器是否相等
    - `*iter`: 
    - `iter->mem`
    - `++iter`
    - `--iter`
  - 迭代器类型:
    - iterator：对象可读可写
    - const_iterator: 能读取但是不能修改它所指元素的值
  - 结合解引用和成员访问操作
    - 解引用: *iter
    - 成员访问操作: (*it).empty()
    - `->`操作结合了解引用和成员访问操作: `it->mem` == `(*iter).mem`

#### 3.4.2 迭代器运算

  - 迭代器的算术运算: 迭代器和一个整数值相加，返回向前或者向后移动若干个位置的迭代器
  - 使用迭代器运算

### 3.5 数组

#### 3.5.1 定义和初始化内置数组

  - 声明数组: `a[d]` 声明时数组的维度必须是一个常量表达式
  - 显示初始化数组元素
  - 字符数组的特殊性: 声明时要加上空字符，如果没有则会被默认添加
  - 数组之间不允许拷贝和赋值;
  - 理解复杂的数组声明
    - 可以定义存放指针的数组 `int* p[10]`
      ```c++
      int *ptrs[10]; // 声明一个数组，存放十个指针
      int (*parray)[10] = &arr; // 声明一个含有十个整数数组的指针 parray是指针的名字，指向一个数组
      int (&arrRef)[10] = arr; // arrRef引用一个含有10个整数的数组
      int *(&arry)[10] = ptrs; // arry 是数组的引用，该数组含有10个指针
      ```

#### 3.5.2 访问数组元素

数组下标通常用size_t定义，size_t是一种机器相关的无符号数。

#### 3.5.3 指针和数组

  - 在使用数组的时候，编译器会把它转化为指针；
  - 在程序中用到数组名字的地方，编译器会把它替换为指向数组首元素的指针；
    ```c++
    string *p2 = nums; // 等价于 p2 = &nums[0]
    ```
  - 数组的操作实际上是指针的操作:
    - 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组；
    - 当用decltype关键字是上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组；
      ```c++
      decltype(ia) ia3 = {0, 1, 2, 3,...}
      ```
  - 指针也是迭代器: 可以将数组元素的指针当做迭代器使用
  - 标准库函数begin 和 end
    - 数组不是类类型，因此这两个函数不是成员函数
      ```c++
      int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
      int *beg = begin(ia);
      int *end = end(ia);
      ```
  - 指向数组元素的指针可以执行以下运算: 解引用、递增、比较、与整数相加、两个指针相减等
  - 解引用和指针运算的交互
  - 下标和指针


#### 3.5.4 C风格字符串

  - 字符串存放在字符数组中并以空字符结尾
  - C标准string函数<cstring>:
  - 比较字符串
    - 普通比较关系符用在c风格字符串上，其实比较的是两个指针的大小关系
    - 方法: 调用strcmp(): 相等返回0， 前面较大返回正值， 反之返回负值


#### 3.5.5 与旧代码的接口

  - 混用string和c风格字符串
  - 使用数组初始化vector对象

### 3.6 多维数组

  - 多维数组的初始化
  - 多维数组的下标引用
  - 使用for循环处理多维数组
    - 选用引用类型作为循环控制变量类型
  - 指针的多维数组
    - 多维数组的名字实际是指向第一维数组的指针
  - 类型别名简化多维数组指针 



## chapter 4 表达式

### 4.1 基础

#### 4.1.1 基础概念

  - 一元运算符: 作用于一个运算对象
    - 例如: `&`取地址符、`*`解引用符
  - 二元运算符: 作用于两个运算对象
    - 例如：`==`相等运算符、`*`乘法运算符
  - 三元运算符
  - 函数调用也是一种运算符

  - 组合运算符和运算对象
  - 运算对象转换
  - <font color=red>重载运算符</font>： 当运算符作用于类类型时候，用户可以自定义其含义
  - <font color=red>左值和右值</font>：<u>当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的地址)</u>
    - 重要原则: 在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用；  
    - 几个左值运算对象
    - decltype例子
      - 假定p的类型是int*,解引用生成左值，所以decltype(*p)的结果是一个&int；
      - 取地址符生成右值，所以decltype(&p)的结果是int**，指向指针的指针

#### 4.1.2 优先律与结合律

#### 4.1.3 求值顺序
  - 明确规定求职顺序的运算符:
    - 逻辑与运算符(`&&`):先求左侧运算对象的值，只有当左侧为真时，再求右侧；
    - 另外三种：逻辑或(`||`)、条件(`?:`)、逗号(`,`)

  - 求值顺序、优先级和结合律

### 4.2 算术运算符

### 4.3 逻辑和关系运算符
  - 逻辑与和逻辑或
    - 短路求值：逻辑与和逻辑或都是先确定左值，再求右值
  - 逻辑非：

#### 2.2.2
####
####
####
####

