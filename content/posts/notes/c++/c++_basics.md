---
title: "C++_basics"
slug: ""
date: 2022-11-09T19:52:47+08:00
summary: ""
author: ["Jian"]
cover:
    image: ""
    alt: ""
tags: []
katex: true
mermaid: false
draft: true
---

一.常考C++基础概念

1.C++三大特性（封装、继承、多态）

**封装：**

>隐藏类的属性和实现细节，仅仅对外提供接口，
封装性实际上是由编译器去识别关键字public、private和protected来实现的，
体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。
私有成员是在封装体内被隐藏的部分，只有类体内说明的函数(类的成员函数)才可以访问私有成员，
而在类体外的函数是不能访问的，公有成员是封装体与外界的一个接口，
类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和该类的派生类才可以访问的。
 
> 优点：隔离变化；便于使用；提高重用性；提高安全性
> 缺点：如果封装太多，影响效率；使用者不能知道代码具体实现。

**继承：**
> 被继承的是父类（基类），继承出来的类是子类（派生类），子类拥有父类的所有的特性。
 继承方式有公有继承、私有继承，保护继承。默认是**私有继承**
 
    *公有继承中父类的公有和保护成员在子类中不变，私有的在子类中不可访问。
    *私有继承中父类的公有和保护成员在子类中变为私有，但私有的在子类中不可访问。
    *保护继承中父类的公有和保护成员在子类中变为保护，但私有的在子类中不可访问。
     c++语言允许单继承和多继承，
     
    优点：继承减少了重复的代码、继承是多态的前提、继承增加了类的耦合性；
    缺点：继承在编译时刻就定义了，无法在运行时刻改变父类继承的实现；
> 父类通常至少定义了子类的部分行为，父类的改变都可能影响子类的行为；
> 如果继承下来的子类不适合解决新问题，父类必须重写或替换，那么这种依赖关系就限制了灵活性，
最终限制了复用性。
 
> 虚继承：为了解决多重继承中的二义性问题，它维护了一张虚基类表。

**<font color=red>多态的四种表现形式</font>**
ref: [多态的四种表现形式](https://blog.csdn.net/weixin_42678507/article/details/97111466?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164515036016780269828775%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164515036016780269828775&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-97111466.pc_search_result_cache&utm_term=%E5%A4%9A%E6%80%81%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F&spm=1018.2226.3001.4187)


2.数组和链表的区别

数组和链表是两种不同的数据存储方式

**<font color=purple>数组的定义</font>**

> 

    数组是一组具有相同数据类型的变量的集合，这些变量称之为集合的元素

    每个元素都有一个编号，称之为下标，可以通过下标来区别并访问数组元素，数组元素的个数叫做数据的长度

**<font color=purple>链表的定义</font>**

> 链表是一种物理存储单元上非连续、非顺序的存储结构,数据元素的逻辑顺序是通过链表中的指针链接次序实现的

    链表的特性是在中间任意位置插入和删除元素都非常快，不需要移动其它元素

    对于单向链表而言，链表中的每一个元素都要保存一个指向下一个元素的指针

    对于双向链表而言，链表中的每个元素既要保存指向下一个元素的指针，又要保存指向上一个元素的指针

    对于双向循环链表而言，链表中的最后一个元素保存一个指向第一个元素的指针


**<font color=purple>数组和链表的区别主要表现在以下几个方面</font>**
|  比较   | 数组  | 链表   |
|  ----  | ----  | ---   |
| 逻辑结构  | 1）数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；(3) 数组元素增加时，有可能会数组越界；(4) 数组元素减少时，会造成内存浪费；（5）数组增删时需要移动其它元素 |1）链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素 (3) 需要时可以使用malloc或者new来申请内存，不用时使用free或者delete来释放内存|
| 内存结构  | 数组从栈上分配内存，使用方便，但是自由度小 |链表从堆上分配内存，自由度大，但是要注意内存泄漏|
| 访问效率  | 数组在内存中顺序存储，可通过下标访问，访问效率高 |链表访问效率低，如果想要访问某个元素，需要从头遍历|
| 越界问题  | 数组的大小是固定的，所以存在访问越界的风险 | 越界的风险	只要可以申请得到链表空间，链表就无越界风险|

**<font color=purple>数组和链表的使用场景</font>**
|  比较   | 数组使用场景  | 	链表使用场景   |
|  ----  | ----  | ---   |
|空间|数组的存储空间是栈上分配的，存储密度大，当要求存储的大小变化不大时，且可以事先确定大小，宜采用数组存储数据|链表的存储空间是堆上动态申请的，当要求存储的长度变化较大时，且事先无法估量数据规模，宜采用链表存储|
|时间|数组访问效率高。当线性表的操作主要是进行查找，很少插入和删除时，宜采用数组结构|链表插入、删除效率高，当线性表要求频繁插入和删除时，宜采用链表结构|

**智能指针** 

我们知道除了静态内存和栈内存外，每个程序还有一个**内存池**，这部分内存被称为自由空间或者堆。程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。

在C++中，动态内存的管理是用一对运算符完成的：new和delete，new:在动态内存中为对象分配一块空间并返回一个指向该对象的指针，delete：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。

动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。

为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。标准库提供的两种智能指针的区别在于管理底层指针的方法不同，**shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象**。标准库还定义了一种名为**weak_ptr的伴随类**，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。

1 智能指针的作用

  智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源

2  智能指针的种类

shared_ptr、unique_ptr、weak_ptr、auto_ptr 

[四种指针详情](https://blog.csdn.net/weixin_41969690/article/details/107912842?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164499296416780274187959%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164499296416780274187959&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-107912842.pc_search_result_cache&utm_term=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187)

3 智能指针的实现原理

智能指针的实现原理就是在一个类的内部封装了类对象的指针，然后在析构函数里对我们的类对象指针进行释放，因为类的析构是在类对象生命期结束时自动调用的，这样我们就省去了手动释放内存的操作，避免忘记手动释放导致的内存泄漏。


**重载、重写、重定义**

1）重载（overload）：  
指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。
    a 相同的范围（在同一个类中）
    b 函数名字相同、 参数不同
    c virtual关键字可有可无
    d 返回值可以不同；

2） 重写（覆盖override)是指派生类函数覆盖基类函数，特征是：
   a 不同的范围，分别位于基类和派生类中
   b 函数的名字相同、 参数相同
   c 基类函数必须有virtual关键字，不能有static
   d 返回值相同（或者协变），否则报错；
   e 重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public, protected也是可以的

3） 重定义(隐藏redefine)是指派生类的函数屏蔽了与其同名的基类函数，特征是：
   a 不在同一个作用域（分别位于派生类与基类）
   b 函数名字相同
   c 返回值可以不同
   d 规则：

如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏；

如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。

ps: 多态性可以分为静态多态性（方法的重载，一个类）和动态多态性（方法的覆盖，有继承关系的类之间的行为）。进而多态性可以由重载和覆盖来实现。

5.static与const区别和作用

static:
1.**static局部变量**将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完不会释放，而是继续保留在内存中；
2.**static全局变量**表示一个变量在当前文件的全局可以访问；
3.**static函数**表示一个函数只能在当前文件中被访问；
4.**static类成员变量**表示这个成员为全类所共有；
5.**static类成员函数**表示这个函数为全类所有，且只能访问成员变量。
6.全局变量在整个工程文件内有效；静态全局变量只在定义它的文件中有效；
7.静态局部变量只在定义它的函数内有效，且程序只分配一次内存，函数返回时不会释放，下次调用时不会重新赋值，还保留上次结果值；局部变量在函数返回时就释放掉；
8.全局变量和静态变量编译器会默认初始化为0；局部变量的默认值未知；
9.局部静态变量与全局变量共享全局数据，但是静态局部变量值在定义该变量的函数内部可见。
10.静态成员（静态成员函数）与配静态成员（成员函数）的区别在于有无this指针；静态成员是静态存储，必须进行初始化；
11.静态成员函数访问非静态成员报错：静态成员在类加载时就已经分配内存，而此时非静态成员尚未分配内存，访问不存在的内存自然会报错；

const

1.<font color=red>const常量</font> 定义时必须初始化，以后不能修改；
2.<font color=red>const形参</font> 该形参在函数里不能被修改；
3.<font color=red>const修饰类成员函数</font> 该函数对成员变量只能进行读操作；

static关键字作用

1.函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此该值在下次调用时还维持上一次的值；
2.在模块内的static函数和变量可以被可以被模块内的函数访问，不能被模块外的函数访问；
3.在类内的static成员变量为整个类所有，类的所有对象只有一份拷贝；
4.在类内的static成员函数为整个类所有，这个函数不接收this指针，因此只能访问类的static成员变量；

const关键字

1.阻止一个变量被改变；
2.声明常量指针和指针常量；
3.const修饰形参，表示为输入参数，在函数体内不能修改该参数的值；
4.const修饰成员函数，表明为一个常函数，不能修改成员变量的值；
5.类的成员函数，有时必须返回const类型的值，使得返回值不能为左值。

const修饰指针有三种情况

1. const修饰指针 --- 常量指针 (const修饰的是指针,指针指向可以改,指针指向的值不可以更改)

```c++ 
    const int * p1 = &a;
    p1 = &b; //正确
    //*p1 = 100; 报错
```
2. const修饰常量 --- 指针常量 (const修饰的是常量,指针指向不可以改,指针指向的值可以更改)

```c++
int * const p2 = &a;
//p2 = &b; //错误
*p2 = 100; //正确
```

3. const即修饰指针,又修饰常量 (const既修饰指针又修饰常量，都不可以改)

```c++
const int * const p3 = &a;
//p3 = &b; //错误
//*p3 = 100; //错误
```
技巧:看const右侧紧跟着的是指针还是常量, 是指针就是常指针,是常量就是指针常量





