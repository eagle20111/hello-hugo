<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jian&#39;s Blog</title>
    <link>https://jianye0428.github.io/en/</link>
    <description>Recent content on Jian&#39;s Blog</description>
    <image>
      <url>https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png</url>
      <link>https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 21 Dec 2022 21:29:32 +0800</lastBuildDate><atom:link href="https://jianye0428.github.io/en/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>EMPlanner</title>
      <link>https://jianye0428.github.io/en/posts/notes/planning/emplanner/</link>
      <pubDate>Wed, 21 Dec 2022 21:29:32 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/planning/emplanner/</guid>
      <description>https://blog.csdn.net/qq_41667348/category_11789612.html https://zhuanlan.zhihu.com/p/492988036 https://www.zhihu.com/column/c_1020971709242818560 https://blog.csdn.net/qq_35503971/article/details/106337900 简介 EM Planner是Apollo面向L4的实时运动规划算法，该算法首先通过顶层多车道策略，选择出一条参考路径，再根据这条参考线，在</description>
    </item>
    
    <item>
      <title>LatticePlanner</title>
      <link>https://jianye0428.github.io/en/posts/notes/planning/latticeplanner/</link>
      <pubDate>Wed, 21 Dec 2022 21:08:44 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/planning/latticeplanner/</guid>
      <description>一、Lattice Planner简介 LatticePlanner算法属于一种局部轨迹规划器，输出轨迹将直接输入到控制器，由控制器完成对局部轨</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11、C&#43;&#43;14、C&#43;&#43;17、C&#43;&#43;20新特性总结</title>
      <link>https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-12-14_c&#43;&#43;_newfeature/</link>
      <pubDate>Wed, 14 Dec 2022 11:00:08 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-12-14_c&#43;&#43;_newfeature/</guid>
      <description>ref: [1]. https://blog.csdn.net/qq_41854911/article/details/119657617 C++ 11 新特性总结 C++ 11是什么，C++ 11标准的由来 C++ 这门编程语言的历史可以追溯至 1979 年，当时的 Bjarne Stroustrup（C++ 之父，后续简称</description>
    </item>
    
    <item>
      <title>2022 12 04_C&#43;&#43;_</title>
      <link>https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-12-04_c&#43;&#43;_/</link>
      <pubDate>Wed, 07 Dec 2022 09:05:24 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-12-04_c&#43;&#43;_/</guid>
      <description>ref: [1]. https://blog.csdn.net/Yangy_Jiaojiao/article/details/127588598 [2]. https://blog.csdn.net/Yangy_Jiaojiao/article/details/128145609 1. 基础知识（一） 1.1 C++语言的特点 ①C++在C的基础上引入了面向对象机制，同时也兼容C语言； ②C++三大特性：封装、继承、多态； ③</description>
    </item>
    
    <item>
      <title>CUDA_C_CH05</title>
      <link>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch05/</link>
      <pubDate>Thu, 01 Dec 2022 16:03:41 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch05/</guid>
      <description>第5章 共享内存和常量内存 了解数据在共享内存中是如何被安排的 掌握从二维共享内存到线性全局内存的索引转换 解决不同访问模式中存储体中的冲突 在共享内</description>
    </item>
    
    <item>
      <title>CUDA_C_CH04</title>
      <link>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch04/</link>
      <pubDate>Tue, 29 Nov 2022 21:08:29 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch04/</guid>
      <description>CH04 全局内存 4.1 CUDA内存模型概述 在现有的硬件存储子系统下， 必须依靠内存模型获得最佳的延迟和带宽。 CUDA内存模结合了主机和设备的内存系统， 展</description>
    </item>
    
    <item>
      <title>CUDA_C_CH03</title>
      <link>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch03/</link>
      <pubDate>Tue, 29 Nov 2022 19:30:04 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch03/</guid>
      <description>CH03 CUDA执行模型 3.1 CUDA执行模型概述 CUDA执行模型能够提供有助于在指令吞吐量和内存访问方面编写高效代码的见解 3.1.1 GPU架构概述 GPU架构</description>
    </item>
    
    <item>
      <title>CUDA_C_CH02</title>
      <link>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch02/</link>
      <pubDate>Sun, 27 Nov 2022 20:14:17 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch02/</guid>
      <description>CH02 CUDA编程模型 2.1 CUDA编程模型概述 CUDA编程模型提供了一个计算机架构抽象作为应用程序和其可用硬件之间的桥梁。 CUDA编程模型还利用G</description>
    </item>
    
    <item>
      <title>CUDA_C_CH01</title>
      <link>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch01/</link>
      <pubDate>Sun, 27 Nov 2022 15:31:58 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch01/</guid>
      <description>Ch01 基于CUDA的异构并行计算 1.1 并行计算 并行计算通常设计两个不同的计算机领域 计算机架构(硬件)：在结构级别上支持并行性 并行程序设计(软件)：充</description>
    </item>
    
    <item>
      <title>Zhito</title>
      <link>https://jianye0428.github.io/en/posts/notes/work/zhito/</link>
      <pubDate>Tue, 22 Nov 2022 17:04:51 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/work/zhito/</guid>
      <description>LaneGCN模型移植和部署 LaneGCN模型 一、数据处理 (1) read_argo_data(): data[&amp;lsquo;city&amp;rsquo;] data[&amp;rsquo;traj&amp;rsquo;]: shape: 32 x 50 x 2 data[&amp;lsquo;steps&amp;rsquo;]: shape: 32 x 50 (2) get_obj_feat(): data[&amp;lsquo;feat&amp;rsquo;]: 障碍物前20秒轨迹点的相对位置坐标（vecto</description>
    </item>
    
    <item>
      <title>分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析</title>
      <link>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022_11_21_distributedtraining_5/</link>
      <pubDate>Mon, 21 Nov 2022 14:27:29 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022_11_21_distributedtraining_5/</guid>
      <description>1. 概述 分布式训练服务框架与集合通信库的组合构成了分布式训练的整体服务软件栈，在第3篇、第4篇文章里已经剖析完集合通信的相关内容，而本文会以H</description>
    </item>
    
    <item>
      <title>CUDA_1</title>
      <link>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_1/</link>
      <pubDate>Mon, 21 Nov 2022 13:57:14 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_1/</guid>
      <description>[1] https://blog.csdn.net/Augusdi/article/details/12187291 CUDA编程 1.什么是CUDA CUDA(Compute Unified Device Architecture)，统一计算架构，是NVidia推出的并行计算平台。NVidia官方对其的解</description>
    </item>
    
    <item>
      <title>C&#43;&#43;_basics</title>
      <link>https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-11-10_c&#43;&#43;_basics/</link>
      <pubDate>Wed, 09 Nov 2022 19:52:47 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-11-10_c&#43;&#43;_basics/</guid>
      <description>一.常考C++基础概念 1.C++三大特性（封装、继承、多态） 封装： 隐藏类的属性和实现细节，仅仅对外提供接口， 封装性实际上是由编译器去识别关键</description>
    </item>
    
    <item>
      <title>C&#43;&#43;_PRIMER Notes</title>
      <link>https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-11-05_c&#43;&#43;_primer/</link>
      <pubDate>Sat, 05 Nov 2022 12:50:16 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-11-05_c&#43;&#43;_primer/</guid>
      <description>2.4 2.4.2 指针和const const指针 常量指针(const pointer)：必须初始化，存放在指针中的地址的值不能改变 1 2 int *const curRrr = &amp;amp;errNumb; const double *const pip = &amp;amp;pi;</description>
    </item>
    
    <item>
      <title>分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法</title>
      <link>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022-11-01_distributedtraining_4/</link>
      <pubDate>Tue, 01 Nov 2022 09:11:20 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022-11-01_distributedtraining_4/</guid>
      <description>ref: [1]. https://www.changping.me/2022/04/10/ai-distributed-training-coll-topo/ 1. 概述 在深度学习的分布式训练里，Ring AllReduce拓扑算法奠定了数据并行训练的集合通信基础，但集合通信拓扑不只是仅有Ring A</description>
    </item>
    
    <item>
      <title>分布式训练 – 第3篇 - 集合通信及其通信原语</title>
      <link>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022-10-31_distributedtraining_3/</link>
      <pubDate>Mon, 31 Oct 2022 07:31:46 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022-10-31_distributedtraining_3/</guid>
      <description>ref: [1]. https://zhuanlan.zhihu.com/p/493092647 概述 集合通信（Collective Communications）是一个进程组的所有进程都参与的全局通信操作，其最为基础的操作有 发送se</description>
    </item>
    
    <item>
      <title>分布式训练 – 第2章 - 训练与系统评价指标</title>
      <link>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022-10-29_distributedtraining_2/</link>
      <pubDate>Sat, 29 Oct 2022 17:44:05 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022-10-29_distributedtraining_2/</guid>
      <description>ref: [1]. https://zhuanlan.zhihu.com/p/492667659 前言 不同于教科书里讲的深度学习的评价指标，这里主要讲述生产训练中常用的评价指标。通常在分布式训练中对训练的过程与结果会进行评价，比如选</description>
    </item>
    
    <item>
      <title>分布式训练 – 第1章 - 什么是分布式训练</title>
      <link>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022-10-29_distributedtraining_1/</link>
      <pubDate>Sat, 29 Oct 2022 16:37:17 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/distributedtraining/2022-10-29_distributedtraining_1/</guid>
      <description>ref: [1]. https://zhuanlan.zhihu.com/p/487945343 前言 深度学习软件工程具有一体两面性：单卡的功能完备性、质量、用户体验以及多卡大规模。多卡大规模的出现是为了解决这样一个主要矛盾，即：“</description>
    </item>
    
    <item>
      <title>Transformer Overview</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-10-09_transformer/</link>
      <pubDate>Sun, 09 Oct 2022 13:24:38 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-10-09_transformer/</guid>
      <description>reference: [1]. The Transformer Family [2]. Attention [3]. 细节考究 Transformer Family Notations Symbol Meaning $d$ The model size / hidden state dimension / positional encoding size. $h$ The number of heads in multi-head attention layer. $L$ The segment length of input sequence. $X \in \mathbb R ^ {L \times d}$ The input sequence where each element has been mapped into an embedding vector of shape , same</description>
    </item>
    
    <item>
      <title>深度学习分布式训练框架 horovod(3) --- Horovodrun背后做了什么</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-10-09_horovod_3/</link>
      <pubDate>Sun, 09 Oct 2022 10:49:10 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-10-09_horovod_3/</guid>
      <description>references: [1]. https://www.cnblogs.com/rossiXYZ/p/14881812.html 0 摘要 Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，在业界得到了广泛应用。 本系列将通过源码分析来带领大家了解 Ho</description>
    </item>
    
    <item>
      <title>深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-10-08_horovod_2/</link>
      <pubDate>Sat, 08 Oct 2022 17:25:41 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-10-08_horovod_2/</guid>
      <description>reference: [1].https://www.cnblogs.com/rossiXYZ/p/14856543.html 0 摘要 Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，在业界得到了广泛应用。 本系列将通过源码分析来带领大家了解 Hor</description>
    </item>
    
    <item>
      <title>深度学习分布式训练框架 Horovod[1] -- 基础知识</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-10-08_horovod_1/</link>
      <pubDate>Sat, 08 Oct 2022 09:30:08 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-10-08_horovod_1/</guid>
      <description>0 摘要 Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，在业界得到了广泛应用。 本系列将通过源码分析来带领大家了解 Horov</description>
    </item>
    
    <item>
      <title>分类问题与回归问题指标综述</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-08-16_classification_and_regression_metrics/</link>
      <pubDate>Tue, 16 Aug 2022 15:37:02 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-08-16_classification_and_regression_metrics/</guid>
      <description>ref: [1] https://www.cnblogs.com/rushup0930/p/13359513.html [2] https://blog.csdn.net/u013250861/article/details/123029585#t12 [3] https://blog.csdn.net/wf592523813/article/details/95202448 [4] https://zhuanlan.zhihu.com/p/69101372 classification 分类 主要涉及的知识点： 混淆矩阵、Precision(精准率)、Recall(召回率)、Accuracy(准确率)、F1-</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL (Standard Template Library) Containers</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-08-01_c&#43;&#43;_data_structure/</link>
      <pubDate>Mon, 01 Aug 2022 09:01:45 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-08-01_c&#43;&#43;_data_structure/</guid>
      <description>C++ STL (Standard Template Library) 总结 C++ STL 容器是使用频率超高的基础设施，只有了解各个容器的底层原理，才能得心应手地用好不同的容器，做到用最合适的容器干最合适的事情。</description>
    </item>
    
    <item>
      <title>[Distributed Training] Horovod_and_Openmpi</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-07-27_horovod_and_openmpi/</link>
      <pubDate>Wed, 27 Jul 2022 17:31:57 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-07-27_horovod_and_openmpi/</guid>
      <description>Horovod 介绍 Horovod 是 Uber 开源的深度学习工具，它的发展吸取了Facebook &amp;ldquo;Training ImageNet In 1 Hour&amp;rdquo; 与百度 &amp;ldquo;Ring Allreduce&amp;rdquo; 的优点，在保证分布式训练性能的同时，兼顾了前端的简洁和对不</description>
    </item>
    
    <item>
      <title>Software Installation Notes</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-07-19_softwareinstallation/</link>
      <pubDate>Tue, 19 Jul 2022 16:02:47 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-07-19_softwareinstallation/</guid>
      <description>一、 apt-get source update apt-get source change the /etc/apt/sources.list file to aliyun source add sudo user in rootlink 1 adduser [name] 1 apt-get install sudo 赋予用户sudo权限: 1 2 3 sudo usermod -a -G adm username sudo usermod -a -G sudo username su [name] 在文件/etc/sudoers 中</description>
    </item>
    
    <item>
      <title>Docker安装及学习</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-07-15_docker/</link>
      <pubDate>Thu, 14 Jul 2022 17:42:53 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-07-15_docker/</guid>
      <description>docker 入门教程 Ref Link: [1] https://ruanyifeng.com/blog/2018/02/docker-tutorial.html [2] https://cloud.tencent.com/developer/article/1885678 [3] 「Docker」 - 保存镜像 [4] 如何制作Docker镜像(image)? 一、Docker 是什么？ &amp;amp;&amp;amp; Docker 的用途 Docker 属于 Linux 容器的</description>
    </item>
    
    <item>
      <title>Target driveN Trajectory: DenseTNT and TNT</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-07-09_densetnt_and_tnt/</link>
      <pubDate>Sat, 09 Jul 2022 19:04:08 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-07-09_densetnt_and_tnt/</guid>
      <description>TNT: Target-driveN Trajectory Prediction **ref link:** https://zhuanlan.zhihu.com/p/435953928 https://blog.csdn.net/weixin_40633696/article/details/124542807?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-2-124542807-blog-122758833.pc_relevant_vip_default&amp;amp;spm=1001.2101.3001.4242.2&amp;amp;utm_relevant_index=5 概览 在预测车辆的轨迹时, 需要尽可能考虑到车辆不同的情况，即不同的模态，如前行或左转，并预测出对应的概率。 模态的定义是比较模糊</description>
    </item>
    
    <item>
      <title>KnapSack Problem</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-06-27_knapsack/</link>
      <pubDate>Sun, 03 Jul 2022 15:32:33 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-06-27_knapsack/</guid>
      <description>dp: https://juejin.cn/post/6844903993429196813 knapsack problem: https://blog.csdn.net/qq_38410730/article/details/81667885 完全背包问题: https://www.cnblogs.com/darkerg/p/15464987.html KnapSack 背包问题 Definiton 定义 背包问题是一种组合优化的NP完全问题:有N个物品和容量为W的背包，每个物品都有自己的体积w和价值v</description>
    </item>
    
    <item>
      <title>Sorting Algorithms</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-06-27_sort_algo/</link>
      <pubDate>Mon, 27 Jun 2022 19:30:04 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-06-27_sort_algo/</guid>
      <description>Sorting Algotithms Collection Quick Sort 快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void quick_sort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int l, int r) { if (l + 1 &amp;gt;= r) { return; } int first = l, last = r - 1, key = nums[first]; while (first &amp;lt; last) { while (first &amp;lt; last &amp;amp;&amp;amp; nums[last] &amp;gt;=</description>
    </item>
    
    <item>
      <title>VectorNet: Encoding HD Maps and Agent Dynamics from Vectorized Representation</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-06-20_vectornet/</link>
      <pubDate>Mon, 20 Jun 2022 15:23:13 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-06-20_vectornet/</guid>
      <description>ref link: [1] https://blog.csdn.net/qq_41897558/article/details/120087113 [2] https://zhuanlan.zhihu.com/p/355131328 ref code: [1]https://github.com/xk-huang/yet-another-vectornet [2]https://github.com/DQSSSSS/VectorNet Novel Highlights (1) 使用矢量化的高精地图以及障碍物的历史轨迹，从而避免有损渲染以及ConvNet编码(计算开销比较大)。 (2) 设计子图网络</description>
    </item>
    
    <item>
      <title>The Utilization of Dataset and DataLoader</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-06-17_pytorch_dataset_dataloader/</link>
      <pubDate>Fri, 17 Jun 2022 18:42:10 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-06-17_pytorch_dataset_dataloader/</guid>
      <description>link: https://chenllliang.github.io/2020/02/04/dataloader/ distributed training with dataloader and dataset: https://blog.csdn.net/zyq12345678/article/details/90268668 https://cloud.tencent.com/developer/article/1877393 Dataset PyTorch为我们提供的两个Dataset和DataLoader类分别负责可被Pytorch使用的数据集的创建以及向</description>
    </item>
    
    <item>
      <title>LaneGCN: Learning Lane Graph Representations for Motion Forecasting</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-06-13_lanegcn/</link>
      <pubDate>Mon, 13 Jun 2022 16:01:19 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-06-13_lanegcn/</guid>
      <description>paper link: https://arxiv.org/abs/2007.13732 PPT: https://www.cs.toronto.edu/~byang/slides/LaneGCN.pdf Architechture Lane Graph + Actor Map: construct lane graph from vectorized map data to preserve the map structure and can avoid information loss 构建矢量化地图信息，避免地图信息丢失 LaneGCN: extends graph convolutions with multiple adjacency matrices and along-lane dilation to capture complex topology and long range dependencies of the lane graph. exploit</description>
    </item>
    
    <item>
      <title>Social_NCE: Contrastive Learning of Socially-aware Motion Representation</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-06-12_social_nce/</link>
      <pubDate>Sun, 12 Jun 2022 09:44:14 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-06-12_social_nce/</guid>
      <description>paper link: https://arxiv.org/abs/2012.11717 论文解读参考: [1] https://zhuanlan.zhihu.com/p/434650863 [2] https://www.gushiciku.cn/pl/amod Issue to solve and its Solution Due to the ill-distributed training Data, it&amp;rsquo;s difficult to capture the notion of the &amp;ldquo;negative&amp;rdquo; examples like collision. Solution: Modeling the negative samples through self-supervision: a social contrastive loss: regularizes the extracted motion representation by discerning the ground-truth positive events from synthetic negative ones; Construct negative samples based on prior</description>
    </item>
    
    <item>
      <title>PyTorch Notes</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-06-09_pytorch/</link>
      <pubDate>Thu, 09 Jun 2022 19:14:27 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-06-09_pytorch/</guid>
      <description>Torch 基本函数 1. torch.einsum() torch.einsum(equation, *operands)-&amp;gt;Tensor:爱因斯坦求和 ref1: 算子部署: https://blog.csdn.net/HW140701/article/details/120654252 ref2: 例子: https://zhuanlan.zhihu.com/p/361209187 三条基本规则: 规则一: equation 箭头左边，在不同输入</description>
    </item>
    
    <item>
      <title>Social_STGCNN: A Social Spatio-Temporal Graph Convolutional Neural Network for Human Trajectory Prediction</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-06-08_social_stgcnn/</link>
      <pubDate>Wed, 08 Jun 2022 16:36:37 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-06-08_social_stgcnn/</guid>
      <description>paper link: https://arxiv.org/abs/2002.11927?from=leiphonecolumn_paperreview0323 网络结构 特点: Social STGCNN不同于其他方法只是聚合各种学习的行人状态，而是对行人交互做图建模。其中提出一种kernel function</description>
    </item>
    
    <item>
      <title>详解最大似然估计(MLE)、最大后验概率估计(MAP)，以及贝叶斯公式的理解</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-05-30_mle/</link>
      <pubDate>Mon, 30 May 2022 16:38:56 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-05-30_mle/</guid>
      <description>最大似然估计（Maximum likelihood estimation, 简称MLE）和最大后验概率估计（Maximum a posteriori estimation, 简称MAP）是很常用的两种参数估计方法，如果不理解这两种</description>
    </item>
    
    <item>
      <title>Machine Learning Algo</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-05-28_ml/</link>
      <pubDate>Sat, 28 May 2022 09:11:55 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-05-28_ml/</guid>
      <description>用pickle保存和加载模型 保存模型 1 2 3 4 5 6 7 import pickle from sklearn.svm import SVC model_dir = &amp;#39;./model.pkl&amp;#39; model = SVC() with open(model_dir, &amp;#39;wb&amp;#39;) as f: pickle.dump(model, f) f.close() # 注意:保存完模型之后要关闭文件 加载模型 1 2 3 4 5</description>
    </item>
    
    <item>
      <title>Numpy Notes</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-05-24_numpy/</link>
      <pubDate>Tue, 24 May 2022 20:52:49 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-05-24_numpy/</guid>
      <description>numpy function 1. np.stack();np.vstack();np.hstack();np.concatenate() 区别 np.concatenate()函数根据指定的维度，对一个元组、列表中的list或者ndarray进行连接 1 2 3 # np.concatenate() numpy.concatenate((a1, a2, ...), axi</description>
    </item>
    
    <item>
      <title>Python Notes</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-05-23_python/</link>
      <pubDate>Mon, 23 May 2022 08:51:45 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-05-23_python/</guid>
      <description>python文件相关 os.path模块 os.path.exists(): 判断当前目录以及文件是否存在 os.path.mkdir(): 若目录或文件不存在，则创建 1 2 3 4 5 6 7 8 9 import os # 目录 dirs = &amp;#39;/Users/joseph/work/python/&amp;#39; if not os.path.exists(dirs): os.makedirs(dirs) #</description>
    </item>
    
    <item>
      <title>Pandas Notes</title>
      <link>https://jianye0428.github.io/en/posts/notes/2022-05-23_pandas/</link>
      <pubDate>Mon, 23 May 2022 08:51:34 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/notes/2022-05-23_pandas/</guid>
      <description>Pandas Notes Input/Output pd.read_csv(filepath): 读取csv文件 ref: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html?highlight=read_csv pd.read_pickle():读取pickle数据 1 2 import pandas pandas.read_pickle(filepath_or_buffer, compression=&amp;#39;infer&amp;#39;, storage_options=None) ref: https://pandas.pydata.org/docs/reference/api/pandas.read_pickle.html Parameters: filepath_or_buffer: 文件名或者文件路径 字符串、路径对象(实</description>
    </item>
    
    <item>
      <title>Linux filesystem</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-05-13_linux_filesystem/</link>
      <pubDate>Fri, 13 May 2022 10:53:31 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-05-13_linux_filesystem/</guid>
      <description>Linux系统各系统文件夹下的区别 首先，usr 指 Unix System Resource，而不是User。 通常， /usr/bin下面的都是系统预装的可执行程序，</description>
    </item>
    
    <item>
      <title>Build VIM 8.2 from source</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-05-11_vim_installation/</link>
      <pubDate>Wed, 11 May 2022 10:00:13 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-05-11_vim_installation/</guid>
      <description>VIM 8.2 安装 1. Install Python3.9 from source Update the packages list and install the packages necessary to build Python 1 sudo apt update &amp;amp;&amp;amp; sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev wget libbz2-dev Download the latest release’s source code from the Python download page using wget 1 wegt https://www.python.org/ftp/python/3.9.0/Python-3.9.1.tgz Switch to the Python source directory</description>
    </item>
    
    <item>
      <title>Git Command Notes</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-05-11_git_command/</link>
      <pubDate>Wed, 11 May 2022 09:59:56 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-05-11_git_command/</guid>
      <description>git command record as my cheatsheet 1. git rebase ref: https://git-scm.com/docs/git-rebase 用法一:git rebase &amp;lt;branch-name&amp;gt; 将topic分支的base由E改为master 1 2 3 A---B---C topic / D---E---F---G master 运行: 1 2 git rebase master git rebase master topic 结果: 1 2 3 A&amp;#39;--B&amp;#39;--C&amp;#39;</description>
    </item>
    
    <item>
      <title>Ubuntu 22.04 | zsh 以及 oh-my-zsh的安装和配置</title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-05-09_zsh_installation/</link>
      <pubDate>Mon, 09 May 2022 11:54:06 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-05-09_zsh_installation/</guid>
      <description>zsh说明 zsh是一个Linux下强大的shell, 由于大多数Linux产品安装以及默认使用bash shell, 但是丝毫不影响极客们对zsh的热衷, 几</description>
    </item>
    
    <item>
      <title>PPO -- Proximal Policy Optimization</title>
      <link>https://jianye0428.github.io/en/posts/tech/rl/2022-05-06_ppo/</link>
      <pubDate>Fri, 06 May 2022 13:16:25 +0200</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/rl/2022-05-06_ppo/</guid>
      <description>PPO Architechture </description>
    </item>
    
    <item>
      <title>DQN -- Deep Q Network</title>
      <link>https://jianye0428.github.io/en/posts/tech/rl/2022-05-05_dqn/</link>
      <pubDate>Thu, 05 May 2022 21:52:44 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/rl/2022-05-05_dqn/</guid>
      <description>[DQN]paper link: https://arxiv.org/pdf/1312.5602v1.pdf DQN: Playing Atari with Deep Reinforcement Learning General Architecture Here is Network listed: play Atari games using RL and perform better than human CNN + Q Learning: CNN for frame-skiped images features extraction; and Q Learning for policy generation Network Channel Kernel Size Stride Activation Output Size Input NA NA NA NA $84\times84\times4$ First Conv 16 8x8 4 Relu $20 \times 20 \times 6$ Second Conv 32</description>
    </item>
    
    
    
    <item>
      <title>TensorRT </title>
      <link>https://jianye0428.github.io/en/posts/tech/2022-04-24_tensorrt/</link>
      <pubDate>Sun, 24 Apr 2022 19:34:50 +0800</pubDate>
      
      <guid>https://jianye0428.github.io/en/posts/tech/2022-04-24_tensorrt/</guid>
      <description>TensorRT 介绍 TensorRT是一个高性能的深度学习推理（Inference）优化器，可以为深度学习应用提供低延迟、高吞吐率的部署推理。Tensor</description>
    </item>
    
  </channel>
</rss>
