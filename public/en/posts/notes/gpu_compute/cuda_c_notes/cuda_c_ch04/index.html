<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CUDA_C_CH04 | Jian&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="CH04 全局内存 4.1 CUDA内存模型概述 在现有的硬件存储子系统下， 必须依靠内存模型获得最佳的延迟和带宽。 CUDA内存模结合了主机和设备的内存系统， 展">
<meta name="author" content="Jian">
<link rel="canonical" href="https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch04/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.1ea9c8832138446635789668415e5c75b8a534b191ee749a44f5ab404c9f27c2.css" integrity="sha256-HqnIgyE4RGY1eJZoQV5cdbilNLGR7nSaRPWrQEyfJ8I=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jianye0428.github.io/favicon/jian_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://jianye0428.github.io/favicon/jian_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jianye0428.github.io/favicon/jian_icon.png">
<link rel="apple-touch-icon" href="https://jianye0428.github.io/favicon/apple-touch-icon.png">
<link rel="mask-icon" href="https://jianye0428.github.io/favicon/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch04/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<meta name="baidu-site-verification" content="code-9oLyeix0aK" />
<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4a41bf85d719f0e8c3165fc76904f546";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>



<script defer crossorigin="anonymous" src="/js/katex.min.8f5024e83d2055dd60e021751066111b0057e230db34911dd56242d67f0a4c86.js" integrity="sha256-j1Ak6D0gVd1g4CF1EGYRGwBX4jDbNJEd1WJC1n8KTIY="></script>


<script defer crossorigin="anonymous" src="/js/auto-render.min.b09accad850e4e87b8a2fc8b93fae790def79172b68de72fd777958c52e566ad.js" integrity="sha256-sJrMrYUOToe4ovyLk/rnkN73kXK2jecv13eVjFLlZq0="></script>

<script>
    
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });

    
    window.WebFontConfig = {
        custom: {
            families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7',
            'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script',
            'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3',
            'KaTeX_Size4', 'KaTeX_Typewriter'],
        },
    };
</script>


<script defer crossorigin="anonymous" src="/js/webfontloader.min.min.d1c6c39d18e2decb5c99dc9efc579098ab37b9654725df3f9c0737bc2dd00760.js" integrity="sha256-0cbDnRji3stcmdye/FeQmKs3uWVHJd8/nAc3vC3QB2A="></script>


 

<script async src="https://www.googletagmanager.com/gtag/js?id=G-C6GDZ56F4S"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-C6GDZ56F4S', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="CUDA_C_CH04" />
<meta property="og:description" content="CH04 全局内存 4.1 CUDA内存模型概述 在现有的硬件存储子系统下， 必须依靠内存模型获得最佳的延迟和带宽。 CUDA内存模结合了主机和设备的内存系统， 展" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch04/" /><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-29T21:08:29&#43;08:00" />
<meta property="article:modified_time" content="2022-11-29T21:08:29&#43;08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"/>

<meta name="twitter:title" content="CUDA_C_CH04"/>
<meta name="twitter:description" content="CH04 全局内存 4.1 CUDA内存模型概述 在现有的硬件存储子系统下， 必须依靠内存模型获得最佳的延迟和带宽。 CUDA内存模结合了主机和设备的内存系统， 展"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jianye0428.github.io/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CUDA_C_CH04",
      "item": "https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch04/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CUDA_C_CH04",
  "name": "CUDA_C_CH04",
  "description": "CH04 全局内存 4.1 CUDA内存模型概述 在现有的硬件存储子系统下， 必须依靠内存模型获得最佳的延迟和带宽。 CUDA内存模结合了主机和设备的内存系统， 展",
  "keywords": [
    
  ],
  "articleBody": "CH04 全局内存 4.1 CUDA内存模型概述 在现有的硬件存储子系统下， 必须依靠内存模型获得最佳的延迟和带宽。 CUDA内存模结合了主机和设备的内存系统， 展现了完整的内存层次结构， 使你能显式地控制数据布以优化性能.s\n4.1.1 内存层次结构的优点 两种不同类型的局部性:\n时间局部性：时间局部性认为如果一个数据位置被引用， 那么该数据在较短的间周期内很可能会再次被引用， 随着时间流逝， 该数据被引用的可能性逐渐降低 空间局部性：空间局部性认为如果一个内存位置被引用， 则附近的位置也可能会被引用 现代计算机使用不断改进的低延迟低容量的内存层次结构来优化性能。 这种内存层次结构仅在支持局部性原则的情况下有效。 一个内存层次结构由具有不同延迟、 带宽容量的多级内存组成。 通常， 随着从处理器到内存延迟的增加， 内存的容量也在增加。\nCPU和GPU的主存都采用的是DRAM（动态随机存取存储器），而低延迟内存（如CPU一级缓存）使用的则是SRAM（静态随机存取存储器）。内存层次结构中最大且最慢的级别通常使用磁盘或闪存驱动来实现。在这种内存层次结构中，当数据被处理器频繁使用时，该数据保存在低延迟、低容量的存储器中；而当该数据被存储起来以备后用时，数据就存储在高延迟、大容量的存储器中。这种内存层次结构符合大内存低延迟的设想。\nGPU和CPU内存模型的主要区别是， CUDA编程模型能将内存层次结构更好地呈现给用户， 能让我们显式地控制它的行为.\n4.1.2 CUDA内存模型 对于程序员来说， 一般有两种类型的存储器：\n可编程的： 你需要显式地控制哪些数据存放在可编程内存中 不可编程的： 你不能决定数据的存放位置， 程序将自动生成存放位置以获得好的性能 在CPU内存层次结构中， 一级缓存和二级缓存都是不可编程的存储器。\nCUDA内存模型提出了多种可编程内存的类型:\n寄存器 (register) 共享内存 (shared memory) 本地内存 (local memory) 常量内存（constant memory） 纹理内存 () 全局内存(global memory) 一个核函数中的线程都有自己私有的本地内存。 一个线程块有自己的共享内存， 对同一线程块中所有线程都可见， 其内容持续线程块的整个生命周期。 所有线程都可以访问全局内存。 所有线程都能访问的只读内存空间有： 常量内存空间和纹理内存空间。 \u003e 全局内存、 常量内存和纹理内存空间有不同的用途。 纹理内存为各种数据布局提供了不同的寻址模式和滤波模式。 对于一个应用程序来说， 全局内存、 常量内存和纹理内存中的内容具有相同的生命周期.\n4.1.2.1 寄存器 寄存器是GPU上运行速度最快的内存空间。\n核函数中声明的一个没有其他修饰符的自变量， 通常存储在寄存器中。 在核函数声明的数组中， 如果用于引用该数组的索引是常量且能在编译时确定， 那么该数组也存储在寄存器中。\n寄存器变量对于每个线程来说都是私有的， 一个核函数通常使用寄存器来保存需要频 繁访问的线程私有变量。 寄存器变量与核函数的生命周期相同。 一旦核函数执行完毕， 就不能对寄存器变量进行访问了。\n寄存器是一个在SM中由活跃线程束划分出的较少资源:\n在Fermi架构中，每个线程最多有63个寄存器； 在Kepler架构中，每个线程最多有255个寄存器；\n在核函数中使用较少的寄存器将使在SM上有更多的常驻线程块。 每个SM上并发线程块越多，使用率和性能就越高\n如果一个核函数使用了超过硬件限制数量的寄存器， 则会用本地内存替代多占用的寄 存器。\n4.1.2.2 本地内存（local memory） 编译器可能存放到本地内存中的变量有：\n在编译时使用未知索引引用的本地数组 可能会占用大量寄存器空间的较大本地结构体或数组 任何不满足核函数寄存器限定条件的变量 “本地内存”这一名词是有歧义的： 溢出到本地内存中的变量本质上与全局内存在同一 块存储区域， 因此本地内存访问的特点是高延迟和低带宽， 并且如在本章后面的4.3节中所描述的那样， 本地内存访问符合高效内存访问要求.\n4.1.2.3 共享内存 在核函数中使用如下修饰符修饰的变量存放在共享内存中： __shared__ 因为共享内存是片上内存， 所以与本地内存或全局内存相比， 它具有更高的带宽和更 低的延迟。 它的使用类似于CPU一级缓存， 但它是可编程的。\n每一个SM都有一定数量的由线程块分配的共享内存。 因此， 必须非常小心不要过度使用共享内存， 否则将在不经意间限制活跃线程束的数量。\n共享内存在核函数的范围内声明， 其生命周期伴随着整个线程块。 当一个线程块执行结束后， 其分配的共享内存将被释放并重新分配给其他线程块。\n共享内存是线程之间相互通信的基本方式。 一个块内的线程通过使用共享内存中的数 据可以相互合作。 访问共享内存必须同步使用如下调用， 该命令是在之前章节中介绍过的CUDA运行时调用： void __syncthreads();\n该函数设立了一个执行障碍点， 即同一个线程块中的所有线程必须在其他线程被允许 执行前达到该处。 为线程块里所有线程设立障碍点， 这样可以避免潜在的数据冲突。\nSM中的一级缓存和共享内存都使用64KB的片上内存， 它通过静态划分， 但在运行时 可以通过如下指令进行动态配置： cudaError_t cudaFuncSetCacheConfig(const void* func, enum cadaFuncCache cacheConfig)\n4.1.2.4 常量内存 常量内存驻留在设备内存中， 并在每个SM专用的常量缓存中缓存。 常量变量用如下 修饰符来修饰: __constant__\n常量变量必须在全局空间内和所有核函数之外进行声明。 对于所有计算能力的设备， 都只可以声明64KB的常量内存。 常量内存是静态声明的， 并对同一编译单元中的所有核函数可见。\n核函数只能从常量内存中读取数据。（不能往常量内存中写数据） 因此， 常量内存必须在主机端使用下面的函数来 初始化： cudaError_t cudaMemoryToSymbol(const void* symbol, const void* src, size_t count)\n这个函数将count个字节从src指向的内存复制到symbol指向的内存中， 这个变量存放在设备的全局内存或常量内存中。\n线程束中的所有线程从相同的内存地址中读取数据时， 常量内存表现最好。\n举个例子， 数学公式中的系数就是一个很好的使用常量内存的例子， 因为一个线程束中所有的线程使用相同的系数来对不同数据进行相同的计算。 如果线程束里每个线程都从不同的地址空间读取数据， 并且只读一次， 那么常量内存中就不是最佳选择， 因为每从一个常量内存中读取一次数据， 都会广播给线程束里的所有线程。\n4.1.2.5 纹理内存 纹理内存是一种通过指定的只读缓存访问的全局内存。 只读缓存包括硬件滤波的支持， 它可以将浮点插入作为读过程的一部分来执行。 纹理内存是对二维空间局部性的优化， 所以线程束里使用纹理内存访问二维数据的线程可以达到最优性能。\n4.1.2.6 全局内存 全局内存是GPU中最大、 延迟最高并且最常使用的内存。 global指的是其作用域和生命周期。 它的声明可以在任何SM设备上被访问到， 并且贯穿应用程序的整个生命周期。\n一个全局内存变量可以被静态声明或动态声明。 你可以使用如下修饰符在设备代码中 静态地声明一个变量：\n__device__\n在第2章的2.1节中， 你已经学习了如何动态分配全局内存。 在主机端使用cuda-Malloc 函数分配全局内存， 使用cudaFree函数释放全局内存。 然后指向全局内存的指针就会作为 参数传递给核函数。 全局内存分配空间存在于应用程序的整个生命周期中， 并且可以访问 所有核函数中的所有线程。 从多个线程访问全局内存时必须注意。 因为线程的执行不能跨 线程块同步， 不同线程块内的多个线程并发地修改全局内存的同一位置可能会出现问题， 这将导致一个未定义的程序行为。\n优化内存事务对于获得最优性能来说是至关重要的。 当一个线程束执行内存加载/ 存储时， 需要满足的传输数量通常取决于以下两个因素：\n跨线程的内存地址分布 每个事务内存地址的对齐方式 对于一个给定的线程束内存请求， 事务数量和数据吞吐率是由设备的计算能力来确定 的。 对于计算能力为1.0和1.1的设备， 全局内存访问的要求是非常严格的。 对于计算能力高于1.1的设备， 由于内存事务被缓存， 所以要求较为宽松。 缓存的内存事务利用数据局部性来提高数据吞吐率。\n4.1.2.7 GPU缓存 跟CPU缓存一样， GPU缓存是不可编程的内存。 在GPU上有4种缓存：\n一级缓存 二级缓存 只读常量缓存 只读纹理缓存 每个SM都有一个一级缓存， 所有的SM共享一个二级缓存。 一级和二级缓存都被用来在存储本地内存和全局内存中的数据， 也包括寄存器溢出的部分。对Fermi GPU和Kepler K40或其后发布的GPU来说， CUDA允许我们配置读操作的数据是使用一级和二级缓存，还是只使用二级缓存。\n在GPU上只有内存加载操作可以被缓存，内存存储操作不能被缓存。 每个SM也有一个只读常量缓存和只读纹理缓存， 它们用于在设备内存中提高来自于各自内存空间内的读取性能。\n4.1.2.8 CUDA变量声明总结 4.1.2.9 静态全局内存 4.2 内存管理 CUDA编程的内存管理与C语言的类似， 需要程序员显式地管理主机和设备之间的数 据移动。 随着CUDA版本的升级， NVIDIA正系统地实现主机和设备内存空间的统一， 但对于大多数应用程序来说， 仍需要手动移动数据。\n分配和释放设备内存 在主机和设备之间传输数据 4.2.1 内存分配和释放 CUDA编程模型假设了一个包含一个主机和一个设备的异构系统， 每一个异构系统都 有自己独立的内存空间。 核函数在设备内存空间中运行， CUDA运行时提供函数以分配和释放设备内存。\n你可以在主机上使用下列函数分配全局内存：\ncudaError_t cudaMalloc(void **devPrt, size_t count);\n这个函数在设备上分配了count字节的全局内存， 并用devptr指针返回该内存的地址。\n你需要用从主机上传输的数据来填充所分配的全局内存， 或用下列函数将其初始 化:\ncudaError_t cudaMemset(void *devPtr, int value, size_t count);\n这个函数用存储在变量value中的值来填充从设备内存地址devPtr处开始的count字节。\n一旦一个应用程序不再使用已分配的全局内存， 那么可以以下代码释放该内存空间： cudaError_t cudaFree(void *devPtr);\n这个函数释放了devPtr指向的全局内存， 该内存必须在此前使用了一个设备分配函数 （如cudaMalloc） 来进行分配。 否则， 它将返回一个错误cudaErrorInvalidDevicePointer。 如果地址空间已经被释放， 那么cudaFree也返回一个错误。\n4.2.2 内存传输 一旦分配好了全局内存， 你就可以使用下列函数从主机向设备传输数据：\ncudaError_t cudaMemory(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind)\n这个函数从内存位置src复制了count字节到内存位置dst。 变量kind指定了复制的方向， 可以有下列取值：\ncudaMemcpyHostToHost cudaMemcpyHostToDevice cudaMemcpyDeviceToHost cudaMemcpyDeviceToDevice CUDA编程的一个基本原则应是尽可能地减少主机与设备之间的传输.\n4.2.3 固定内存 分配的主机内存默认是pageable（可分页） ， 它的意思也就是因页面错误导致的操 作， 该操作按照操作系统的要求将主机虚拟内存上的数据移动到不同的物理位置。 虚拟内存给人一种比实际可用内存大得多的假象， 就如同一级缓存好像比实际可用的片上内存大得多一样。\nGPU不能在可分页主机内存上安全地访问数据， 因为当主机操作系统在物理位置上移 动该数据时， 它无法控制。 当从可分页主机内存传输数据到设备内存时， CUDA驱动程序首先分配临时页面锁定的或固定的主机内存， 将主机源数据复制到固定内存中， 然后从固定内存传输数据给设备内存， 如图4-4左边部分所示\nCUDA运行时允许你使用如下指令直接分配固定主机内存： cudaError_t cudaMallocHost(void **devPtr, size_t count);\n这个函数分配了count字节的主机内存， 这些内存是页面锁定的并且对设备来说是可 访问的。 由于固定内存能被设备直接访问， 所以它能用比可分页内存高得多的带宽进行读写。 然而， 分配过多的固定内存可能会降低主机系统的性能， 因为它减少了用于存储虚拟内存数据的可分页内存的数量， 其中分页内存对主机系统是可用的。\n主机与设备间的内存传输\n与可分页内存相比， 固定内存的分配和释放成本更高， 但是它为大规模数据传输提供 了更高的传输吞吐量\n4.2.4 零拷贝内存 通常来说， 主机不能直接访问设备变量， 同时设备也不能直接访问主机变量。 但有一个例外： 零拷贝内存。 主机和设备都可以访问零拷贝内存。\nGPU线程可以直接访问零拷贝内存。 在CUDA核函数中使用零拷贝内存有以下几个优 势。\n当设备内存不足时可利用主机内存 避免主机和设备间的显式数据传输 提高PCIe传输率 当使用零拷贝内存来共享主机和设备间的数据时， 你必须同步主机和设备间的内存访 问， 同时更改主机和设备的零拷贝内存中的数据将导致不可预知的后果。\n零拷贝内存是固定（不可分页） 内存， 该内存映射到设备地址空间中。 你可以通过下列函数创建一个到固定内存的映射：\ncudaError_t cudaHostAlloc(void **pHost, size_t count, unsigned int flags);\n这个函数分配了count字节的主机内存， 该内存是页面锁定的且设备可访问的。 用这 个函数分配的内存必须用cudaFreeHost函数释放。 flags参数可以对已分配内存的特殊属性 进一步进行配置：\n- cudaHostAllocDefault - cudaHostAllocPortable - cudaHostAllocWriteCombined - cudaHostAllocMapped cudaHostAllocDefault函数使cudaHostAlloc函数的行为与cudaMallocHost函数一致。\n设置cudaHostAllocPortable函数可以返回能被所有CUDA上下文使用的固定内存， 而不仅是执 行内存分配的那一个。\n标志cudaHostAllocWriteCombined返回写结合内存， 该内存可以在某些系统配置上通过PCIe总线上更快地传输， 但是它在大多数主机上不能被有效地读取。因此， 写结合内存对缓冲区来说是一个很好的选择， 该内存通过设备使用映射的固定内存或主机到设备的传输。\n零拷贝内存的最明显的标志是cudaHostAllocMapped， 该标志返回， 可以实现主机写入和设备读取被映射到设备地址空间中的主机内存。\n你可以使用下列函数获取映射到固定内存的设备指针：\ncudaError_t cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);\n该函数返回了一个在pDevice中的设备指针， 该指针可以在设备上被引用以访问映射得到的固定主机内存。 如果设备不支持映射得到的固定内存， 该函数将失效。 flag将留作以后使用。 现在， 它必须被置为0。\n在进行频繁的读写操作时， 使用零拷贝内存作为设备内存的补充将显著降低性能。 因为每一次映射到内存的传输必须经过PCIe总线。 与全局内存相比， 延迟也显著增加。\n零拷贝内存\n有两种常见的异构计算系统架构： 集成架构和离散架构。\n在集成架构中， CPU和GPU集成在一个芯片上， 并且在物理地址上共享主存。 在这种架构中， 由于无须在PCIe总线上备份， 所以零拷贝内存在性能和可编程性方面可能更佳。\n对于通过PCIe总线将设备连接到主机的离散系统而言， 零拷贝内存只在特殊情况下有优势。\n因为映射的固定内存在主机和设备之间是共享的， 你必须同步内存访问来避免任何潜在的数据冲突， 这种数据冲突一般是由多线程异步访问相同的内存而引起的。\n注意不要过度使用零拷贝内存。 由于其延迟较高， 从零拷贝内存中读取设备核函数可能很慢。\n4.2.5 统一虚拟寻址 ",
  "wordCount" : "5773",
  "inLanguage": "en",
  "datePublished": "2022-11-29T21:08:29+08:00",
  "dateModified": "2022-11-29T21:08:29+08:00",
  "author":[{
    "@type": "Person",
    "name": "Jian"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch04/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jian's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jianye0428.github.io/favicon/jian_icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jianye0428.github.io/en/" accesskey="h" title="Jian&#39;s Blog (Alt + H)">
                <img src="https://jianye0428.github.io/favicon/jian_icon.png" alt="logo" aria-label="logo"
                    height="30">Jian&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://jianye0428.github.io/cn/" title="Chinese"
                            aria-label="Chinese">Chinese</a>
                    </li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jianye0428.github.io/en/myresume/" title="My Resume">
                    <span>My Resume</span>
                </a>
            </li>
            <li>
                <a href="https://jianye0428.github.io/en/tags/" title="🔖Tags">
                    <span>🔖Tags</span>
                </a>
            </li>
            <li>
                <a href="https://jianye0428.github.io/en/archives" title="🙋🏻‍♂️Archive">
                    <span>🙋🏻‍♂️Archive</span>
                </a>
            </li>
            <li>
                <a href="https://jianye0428.github.io/en/search/" title="🔍Search (Alt &#43; /)" accesskey=/>
                    <span>🔍Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jianye0428.github.io/en/">Home</a>&nbsp;»&nbsp;<a href="https://jianye0428.github.io/en/posts/">Posts</a></div>
    <h1 class="post-title">
      CUDA_C_CH04
    </h1>
    <div class="post-meta"><span title='2022-11-29 21:08:29 +0800 CST'>2022-11-29</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Jian&nbsp;|&nbsp;<a href="https://github.com/jianye0428/myblog/tree/main/content/posts/notes/GPU_Compute/CUDA_C_Notes/CUDA_C_CH04.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#ch04-%e5%85%a8%e5%b1%80%e5%86%85%e5%ad%98" aria-label="CH04 全局内存">CH04 全局内存</a><ul>
                            
                    <li>
                        <a href="#41-cuda%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e6%a6%82%e8%bf%b0" aria-label="4.1 CUDA内存模型概述">4.1 CUDA内存模型概述</a><ul>
                            
                    <li>
                        <a href="#411-%e5%86%85%e5%ad%98%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e7%9a%84%e4%bc%98%e7%82%b9" aria-label="4.1.1 内存层次结构的优点">4.1.1 内存层次结构的优点</a></li>
                    <li>
                        <a href="#412-cuda%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" aria-label="4.1.2 CUDA内存模型">4.1.2 CUDA内存模型</a><ul>
                            
                    <li>
                        <a href="#4121-%e5%af%84%e5%ad%98%e5%99%a8" aria-label="4.1.2.1 寄存器">4.1.2.1 寄存器</a></li>
                    <li>
                        <a href="#4122-%e6%9c%ac%e5%9c%b0%e5%86%85%e5%ad%98local-memory" aria-label="4.1.2.2 本地内存（local memory）">4.1.2.2 本地内存（local memory）</a></li>
                    <li>
                        <a href="#4123-%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98" aria-label="4.1.2.3 共享内存">4.1.2.3 共享内存</a></li>
                    <li>
                        <a href="#4124-%e5%b8%b8%e9%87%8f%e5%86%85%e5%ad%98" aria-label="4.1.2.4 常量内存">4.1.2.4 常量内存</a></li>
                    <li>
                        <a href="#4125-%e7%ba%b9%e7%90%86%e5%86%85%e5%ad%98" aria-label="4.1.2.5 纹理内存">4.1.2.5 纹理内存</a></li>
                    <li>
                        <a href="#4126-%e5%85%a8%e5%b1%80%e5%86%85%e5%ad%98" aria-label="4.1.2.6 全局内存">4.1.2.6 全局内存</a></li>
                    <li>
                        <a href="#4127-gpu%e7%bc%93%e5%ad%98" aria-label="4.1.2.7 GPU缓存">4.1.2.7 GPU缓存</a></li>
                    <li>
                        <a href="#4128-cuda%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e6%80%bb%e7%bb%93" aria-label="4.1.2.8 CUDA变量声明总结">4.1.2.8 CUDA变量声明总结</a></li>
                    <li>
                        <a href="#4129-%e9%9d%99%e6%80%81%e5%85%a8%e5%b1%80%e5%86%85%e5%ad%98" aria-label="4.1.2.9 静态全局内存">4.1.2.9 静态全局内存</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#42-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="4.2 内存管理">4.2 内存管理</a><ul>
                            
                    <li>
                        <a href="#421-%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%92%8c%e9%87%8a%e6%94%be" aria-label="4.2.1 内存分配和释放">4.2.1 内存分配和释放</a></li>
                    <li>
                        <a href="#422-%e5%86%85%e5%ad%98%e4%bc%a0%e8%be%93" aria-label="4.2.2 内存传输">4.2.2 内存传输</a></li>
                    <li>
                        <a href="#423-%e5%9b%ba%e5%ae%9a%e5%86%85%e5%ad%98" aria-label="4.2.3 固定内存">4.2.3 固定内存</a></li>
                    <li>
                        <a href="#424-%e9%9b%b6%e6%8b%b7%e8%b4%9d%e5%86%85%e5%ad%98" aria-label="4.2.4 零拷贝内存">4.2.4 零拷贝内存</a></li>
                    <li>
                        <a href="#425-%e7%bb%9f%e4%b8%80%e8%99%9a%e6%8b%9f%e5%af%bb%e5%9d%80" aria-label="4.2.5 统一虚拟寻址">4.2.5 统一虚拟寻址</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="ch04-全局内存">CH04 全局内存<a hidden class="anchor" aria-hidden="true" href="#ch04-全局内存">#</a></h2>
<h3 id="41-cuda内存模型概述">4.1 CUDA内存模型概述<a hidden class="anchor" aria-hidden="true" href="#41-cuda内存模型概述">#</a></h3>
<p>在现有的硬件存储子系统下， 必须依靠内存模型获得最佳的延迟和带宽。 CUDA内存模结合了主机和设备的内存系统， 展现了完整的内存层次结构， 使你能显式地控制数据布以优化性能.s</p>
<h4 id="411-内存层次结构的优点">4.1.1 内存层次结构的优点<a hidden class="anchor" aria-hidden="true" href="#411-内存层次结构的优点">#</a></h4>
<p>两种不同类型的局部性:</p>
<ul>
<li>时间局部性：时间局部性认为如果一个数据位置被引用， 那么该数据在较短的间周期内很可能会再次被引用， 随着时间流逝， 该数据被引用的可能性逐渐降低</li>
<li>空间局部性：空间局部性认为如果一个内存位置被引用， 则附近的位置也可能会被引用</li>
</ul>
<p>现代计算机使用不断改进的<strong>低延迟低容量</strong>的内存层次结构来优化性能。 这种内存层次结构仅在支持局部性原则的情况下有效。 一个内存层次结构由具有不同延迟、 带宽容量的多级内存组成。 通常， 随着从处理器到内存延迟的增加， 内存的容量也在增加。</p>
<p>CPU和GPU的主存都采用的是DRAM（动态随机存取存储器），而低延迟内存（如CPU一级缓存）使用的则是SRAM（静态随机存取存储器）。内存层次结构中最大且最慢的级别通常使用磁盘或闪存驱动来实现。在这种内存层次结构中，当数据被处理器频繁使用时，该数据保存在低延迟、低容量的存储器中；而当该数据被存储起来以备后用时，数据就存储在高延迟、大容量的存储器中。这种内存层次结构符合大内存低延迟的设想。</p>
<p>GPU和CPU内存模型的主要区别是， CUDA编程模型能将内存层次结构更好地呈现给用户， 能让我们显式地控制它的行为.</p>
<h4 id="412-cuda内存模型">4.1.2 CUDA内存模型<a hidden class="anchor" aria-hidden="true" href="#412-cuda内存模型">#</a></h4>
<p>对于程序员来说， 一般有两种类型的存储器：</p>
<ul>
<li>可编程的： 你需要显式地控制哪些数据存放在可编程内存中</li>
<li>不可编程的： 你不能决定数据的存放位置， 程序将自动生成存放位置以获得好的性能</li>
</ul>
<p>在CPU内存层次结构中， 一级缓存和二级缓存都是不可编程的存储器。</p>
<p>CUDA内存模型提出了多种可编程内存的类型:</p>
<ul>
<li>寄存器 (register)</li>
<li>共享内存 (shared memory)</li>
<li>本地内存 (local memory)</li>
<li>常量内存（constant memory）</li>
<li>纹理内存 ()</li>
<li>全局内存(global memory)</li>
</ul>
<blockquote>
<p>一个核函数中的线程都有自己私有的本地内存。
一个线程块有自己的共享内存， 对同一线程块中所有线程都可见， 其内容持续线程块的整个生命周期。
所有线程都可以访问全局内存。
所有线程都能访问的<font color=red>只读内存空间</font>有： <strong>常量内存空间</strong>和<strong>纹理内存空间</strong>。 &gt; 全局内存、 常量内存和纹理内存空间有不同的用途。 纹理内存为各种数据布局提供了不同的寻址模式和滤波模式。
对于一个应用程序来说， 全局内存、 常量内存和纹理内存中的内容具有相同的生命周期.</p>
</blockquote>
<h5 id="4121-寄存器">4.1.2.1 寄存器<a hidden class="anchor" aria-hidden="true" href="#4121-寄存器">#</a></h5>
<p>寄存器是GPU上运行速度最快的内存空间。</p>
<p>核函数中声明的一个没有其他修饰符的自变量， 通常存储在寄存器中。  在核函数声明的数组中， 如果用于引用该数组的索引是常量且能在编译时确定， 那么该数组也存储在寄存器中。</p>
<p>寄存器变量对于每个线程来说都是私有的， 一个核函数通常使用寄存器来保存需要频
繁访问的线程私有变量。 寄存器变量与核函数的生命周期相同。 一旦核函数执行完毕， 就不能对寄存器变量进行访问了。</p>
<p>寄存器是一个在SM中由活跃线程束划分出的较少资源:</p>
<p>在Fermi架构中，每个线程最多有63个寄存器；
在Kepler架构中，每个线程最多有255个寄存器；</p>
<p>在核函数中使用较少的寄存器将使在SM上有更多的常驻线程块。 每个SM上并发线程块越多，使用率和性能就越高</p>
<p>如果一个核函数使用了超过硬件限制数量的寄存器， 则会用本地内存替代多占用的寄
存器。</p>
<h5 id="4122-本地内存local-memory">4.1.2.2 本地内存（local memory）<a hidden class="anchor" aria-hidden="true" href="#4122-本地内存local-memory">#</a></h5>
<p>编译器可能存放到本地内存中的变量有：</p>
<ul>
<li>在编译时使用未知索引引用的本地数组</li>
<li>可能会占用大量寄存器空间的较大本地结构体或数组</li>
<li>任何不满足核函数寄存器限定条件的变量</li>
</ul>
<p>“本地内存”这一名词是有歧义的： 溢出到本地内存中的变量本质上与全局内存在同一
块存储区域， 因此本地内存访问的特点是高延迟和低带宽， 并且如在本章后面的4.3节中所描述的那样， 本地内存访问符合高效内存访问要求.</p>
<h5 id="4123-共享内存">4.1.2.3 共享内存<a hidden class="anchor" aria-hidden="true" href="#4123-共享内存">#</a></h5>
<p>在核函数中使用如下修饰符修饰的变量存放在共享内存中：
<code>__shared__</code>
因为共享内存是片上内存， 所以与本地内存或全局内存相比， 它具有更高的带宽和更
低的延迟。 它的使用类似于CPU一级缓存， 但它是可编程的。</p>
<p>每一个SM都有一定数量的由线程块分配的共享内存。 因此， 必须非常小心不要过度使用共享内存， 否则将在不经意间限制活跃线程束的数量。</p>
<p>共享内存在核函数的范围内声明， 其<strong>生命周期伴随着整个线程块</strong>。 当一个线程块执行结束后， 其分配的共享内存将被释放并重新分配给其他线程块。</p>
<p>共享内存是线程之间相互通信的基本方式。 一个块内的线程通过使用共享内存中的数
据可以相互合作。 访问共享内存必须同步使用如下调用， 该命令是在之前章节中介绍过的CUDA运行时调用：
<code>void __syncthreads();</code></p>
<p>该函数设立了一个执行障碍点， 即同一个线程块中的所有线程必须在其他线程被允许
执行前达到该处。 为线程块里所有线程设立障碍点， 这样可以避免潜在的数据冲突。</p>
<p>SM中的一级缓存和共享内存都使用64KB的片上内存， 它通过静态划分， 但在运行时
可以通过如下指令进行动态配置：
<code>cudaError_t cudaFuncSetCacheConfig(const void* func, enum cadaFuncCache cacheConfig)</code></p>
<h5 id="4124-常量内存">4.1.2.4 常量内存<a hidden class="anchor" aria-hidden="true" href="#4124-常量内存">#</a></h5>
<p>常量内存驻留在设备内存中， 并在每个SM专用的常量缓存中缓存。 常量变量用如下
修饰符来修饰:
<code>__constant__</code></p>
<p>常量变量必须在全局空间内和所有核函数之外进行声明。 对于所有计算能力的设备，
都只可以声明64KB的常量内存。 常量内存是静态声明的， 并对同一编译单元中的所有核函数可见。</p>
<p><strong>核函数只能从常量内存中读取数据。（不能往常量内存中写数据）</strong> 因此， 常量内存必须在主机端使用下面的函数来
初始化：
<code>cudaError_t cudaMemoryToSymbol(const void* symbol, const void* src, size_t count)</code></p>
<p>这个函数将count个字节从src指向的内存复制到symbol指向的内存中， 这个变量存放在设备的全局内存或常量内存中。</p>
<p>线程束中的所有线程从相同的内存地址中读取数据时， 常量内存表现最好。</p>
<p>举个例子， 数学公式中的系数就是一个很好的使用常量内存的例子， 因为一个线程束中所有的线程使用相同的系数来对不同数据进行相同的计算。 如果线程束里每个线程都从不同的地址空间读取数据， 并且只读一次， 那么常量内存中就不是最佳选择， 因为每从一个常量内存中读取一次数据， 都会广播给线程束里的所有线程。</p>
<h5 id="4125-纹理内存">4.1.2.5 纹理内存<a hidden class="anchor" aria-hidden="true" href="#4125-纹理内存">#</a></h5>
<p>纹理内存是一种通过<strong>指定的只读缓存访问的全局内存</strong>。 只读缓存包括硬件滤波的支持， 它可以将浮点插入作为读过程的一部分来执行。 纹理内存是对二维空间局部性的优化， 所以线程束里使用纹理内存访问二维数据的线程可以达到最优性能。</p>
<h5 id="4126-全局内存">4.1.2.6 全局内存<a hidden class="anchor" aria-hidden="true" href="#4126-全局内存">#</a></h5>
<p>全局内存是GPU中最大、 延迟最高并且最常使用的内存。 global指的是其作用域和生命周期。 它的声明可以在任何SM设备上被访问到， 并且贯穿应用程序的整个生命周期。</p>
<p>一个全局内存变量可以被静态声明或动态声明。 你可以使用如下修饰符在设备代码中
静态地声明一个变量：</p>
<p><code>__device__</code></p>
<p>在第2章的2.1节中， 你已经学习了如何动态分配全局内存。 在主机端使用cuda-Malloc
函数分配全局内存， 使用cudaFree函数释放全局内存。 然后指向全局内存的指针就会作为
参数传递给核函数。 全局内存分配空间存在于应用程序的整个生命周期中， 并且可以访问
所有核函数中的所有线程。 从多个线程访问全局内存时必须注意。 因为线程的执行不能跨
线程块同步， 不同线程块内的多个线程并发地修改全局内存的同一位置可能会出现问题，
这将导致一个未定义的程序行为。</p>
<p>优化内存事务对于获得最优性能来说是至关重要的。 当一个线程束执行内存加载/
存储时， 需要满足的传输数量通常取决于以下两个因素：</p>
<ul>
<li>跨线程的内存地址分布</li>
<li>每个事务内存地址的对齐方式</li>
</ul>
<p>对于一个给定的线程束内存请求， 事务数量和数据吞吐率是由设备的计算能力来确定
的。 对于计算能力为1.0和1.1的设备， 全局内存访问的要求是非常严格的。 对于计算能力高于1.1的设备， 由于内存事务被缓存， 所以要求较为宽松。 缓存的内存事务利用数据局部性来提高数据吞吐率。</p>
<h5 id="4127-gpu缓存">4.1.2.7 GPU缓存<a hidden class="anchor" aria-hidden="true" href="#4127-gpu缓存">#</a></h5>
<p>跟CPU缓存一样， GPU缓存是不可编程的内存。 在GPU上有4种缓存：</p>
<ul>
<li>一级缓存</li>
<li>二级缓存</li>
<li>只读常量缓存</li>
<li>只读纹理缓存</li>
</ul>
<p><font color=purple>每个SM都有一个一级缓存， 所有的SM共享一个二级缓存。</font> 一级和二级缓存都被用来在存储本地内存和全局内存中的数据， 也包括寄存器溢出的部分。对Fermi GPU和Kepler K40或其后发布的GPU来说， CUDA允许我们配置读操作的数据是使用一级和二级缓存，还是只使用二级缓存。</p>
<p>在GPU上只有内存加载操作可以被缓存，内存存储操作不能被缓存。
每个SM也有一个<strong>只读常量缓存</strong>和<strong>只读纹理缓存</strong>， 它们用于在设备内存中提高来自于各自内存空间内的读取性能。</p>
<h5 id="4128-cuda变量声明总结">4.1.2.8 CUDA变量声明总结<a hidden class="anchor" aria-hidden="true" href="#4128-cuda变量声明总结">#</a></h5>
<h5 id="4129-静态全局内存">4.1.2.9 静态全局内存<a hidden class="anchor" aria-hidden="true" href="#4129-静态全局内存">#</a></h5>
<h3 id="42-内存管理">4.2 内存管理<a hidden class="anchor" aria-hidden="true" href="#42-内存管理">#</a></h3>
<p>CUDA编程的内存管理与C语言的类似， 需要程序员显式地管理主机和设备之间的数
据移动。 随着CUDA版本的升级， NVIDIA正系统地实现主机和设备内存空间的统一， 但对于大多数应用程序来说， 仍需要手动移动数据。</p>
<ul>
<li>分配和释放设备内存</li>
<li>在主机和设备之间传输数据</li>
</ul>
<h4 id="421-内存分配和释放">4.2.1 内存分配和释放<a hidden class="anchor" aria-hidden="true" href="#421-内存分配和释放">#</a></h4>
<p>CUDA编程模型假设了一个包含一个主机和一个设备的异构系统， 每一个异构系统都
有自己独立的内存空间。 核函数在设备内存空间中运行， CUDA运行时提供函数以分配和释放设备内存。</p>
<p>你可以在主机上使用下列函数分配全局内存：</p>
<p><code>cudaError_t cudaMalloc(void **devPrt, size_t count);</code></p>
<p>这个函数在设备上分配了count字节的全局内存， 并用devptr指针返回该内存的地址。</p>
<p>你需要用从主机上传输的数据来填充所分配的全局内存， 或用下列函数将其初始
化:</p>
<p><code>cudaError_t cudaMemset(void *devPtr, int value, size_t count);</code></p>
<p>这个函数用存储在变量value中的值来填充从设备内存地址devPtr处开始的count字节。</p>
<p>一旦一个应用程序不再使用已分配的全局内存， 那么可以以下代码释放该内存空间：
<code>cudaError_t cudaFree(void *devPtr);</code></p>
<p>这个函数释放了devPtr指向的全局内存， 该内存必须在此前使用了一个设备分配函数
（如cudaMalloc） 来进行分配。 否则， 它将返回一个错误cudaErrorInvalidDevicePointer。
如果地址空间已经被释放， 那么cudaFree也返回一个错误。</p>
<h4 id="422-内存传输">4.2.2 内存传输<a hidden class="anchor" aria-hidden="true" href="#422-内存传输">#</a></h4>
<p>一旦分配好了全局内存， 你就可以使用下列函数从主机向设备传输数据：</p>
<p><code>cudaError_t cudaMemory(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind)</code></p>
<p>这个函数从内存位置src复制了count字节到内存位置dst。 变量kind指定了复制的方向， 可以有下列取值：</p>
<ul>
<li><code>cudaMemcpyHostToHost</code></li>
<li><code>cudaMemcpyHostToDevice</code></li>
<li><code>cudaMemcpyDeviceToHost</code></li>
<li><code>cudaMemcpyDeviceToDevice</code></li>
</ul>
<p>CUDA编程的一个基本原则应是尽可能地减少主机与设备之间的传输.</p>
<h4 id="423-固定内存">4.2.3 固定内存<a hidden class="anchor" aria-hidden="true" href="#423-固定内存">#</a></h4>
<p>分配的主机内存默认是pageable（可分页） ， 它的意思也就是因页面错误导致的操
作， 该操作按照操作系统的要求将主机虚拟内存上的数据移动到不同的物理位置。 虚拟内存给人一种比实际可用内存大得多的假象， 就如同一级缓存好像比实际可用的片上内存大得多一样。</p>
<p>GPU不能在可分页主机内存上安全地访问数据， 因为当主机操作系统在物理位置上移
动该数据时， 它无法控制。 当从可分页主机内存传输数据到设备内存时， CUDA驱动程序首先分配临时页面锁定的或固定的主机内存， 将主机源数据复制到固定内存中， 然后从固定内存传输数据给设备内存， 如图4-4左边部分所示</p>
<p>CUDA运行时允许你使用如下指令直接分配固定主机内存：
<code>cudaError_t cudaMallocHost(void **devPtr, size_t count);</code></p>
<p>这个函数分配了count字节的主机内存， 这些内存是页面锁定的并且对设备来说是可
访问的。 由于固定内存能被设备直接访问， 所以它能用比可分页内存高得多的带宽进行读写。 然而， 分配过多的固定内存可能会降低主机系统的性能， 因为它减少了用于存储虚拟内存数据的可分页内存的数量， 其中分页内存对主机系统是可用的。</p>
<p><strong>主机与设备间的内存传输</strong></p>
<p>与可分页内存相比， 固定内存的分配和释放成本更高， 但是它为大规模数据传输提供
了更高的传输吞吐量</p>
<h4 id="424-零拷贝内存">4.2.4 零拷贝内存<a hidden class="anchor" aria-hidden="true" href="#424-零拷贝内存">#</a></h4>
<p>通常来说， 主机不能直接访问设备变量， 同时设备也不能直接访问主机变量。 但有一个例外： 零拷贝内存。 主机和设备都可以访问零拷贝内存。</p>
<p>GPU线程可以直接访问零拷贝内存。 在CUDA核函数中使用零拷贝内存有以下几个优
势。</p>
<ul>
<li>当设备内存不足时可利用主机内存</li>
<li>避免主机和设备间的显式数据传输</li>
<li>提高PCIe传输率</li>
</ul>
<p>当使用零拷贝内存来共享主机和设备间的数据时， 你必须同步主机和设备间的内存访
问， 同时更改主机和设备的零拷贝内存中的数据将导致不可预知的后果。</p>
<p>零拷贝内存是固定（不可分页） 内存， 该内存映射到设备地址空间中。 你可以通过下列函数创建一个到固定内存的映射：</p>
<p><code>cudaError_t cudaHostAlloc(void **pHost, size_t count, unsigned int flags);</code></p>
<p>这个函数分配了count字节的主机内存， 该内存是页面锁定的且设备可访问的。 用这
个函数分配的内存必须用cudaFreeHost函数释放。 flags参数可以对已分配内存的特殊属性
进一步进行配置：</p>
<pre><code>- cudaHostAllocDefault
- cudaHostAllocPortable
- cudaHostAllocWriteCombined
- cudaHostAllocMapped
</code></pre>
<p>cudaHostAllocDefault函数使cudaHostAlloc函数的行为与cudaMallocHost函数一致。</p>
<p>设置cudaHostAllocPortable函数可以返回能被所有CUDA上下文使用的固定内存， 而不仅是执
行内存分配的那一个。</p>
<p>标志cudaHostAllocWriteCombined返回写结合内存， 该内存可以在某些系统配置上通过PCIe总线上更快地传输， 但是它在大多数主机上不能被有效地读取。因此， 写结合内存对缓冲区来说是一个很好的选择， 该内存通过设备使用映射的固定内存或主机到设备的传输。</p>
<p>零拷贝内存的最明显的标志是cudaHostAllocMapped， 该标志返回， 可以实现主机写入和设备读取被映射到设备地址空间中的主机内存。</p>
<p>你可以使用下列函数获取映射到固定内存的设备指针：</p>
<p><code>cudaError_t cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);</code></p>
<p>该函数返回了一个在pDevice中的设备指针， 该指针可以在设备上被引用以访问映射得到的固定主机内存。 如果设备不支持映射得到的固定内存， 该函数将失效。 flag将留作以后使用。 现在， 它必须被置为0。</p>
<p>在进行频繁的读写操作时， 使用零拷贝内存作为设备内存的补充将显著降低性能。 因为每一次映射到内存的传输必须经过PCIe总线。 与全局内存相比， 延迟也显著增加。</p>
<p><strong>零拷贝内存</strong></p>
<p>有两种常见的异构计算系统架构： 集成架构和离散架构。</p>
<p>在集成架构中， CPU和GPU集成在一个芯片上， 并且<strong>在物理地址上共享主存</strong>。 在这种架构中， 由于无须在PCIe总线上备份， 所以零拷贝内存在性能和可编程性方面可能更佳。</p>
<p>对于通过PCIe总线将设备连接到主机的离散系统而言， 零拷贝内存只在特殊情况下有优势。</p>
<p>因为映射的固定内存在主机和设备之间是共享的， 你必须同步内存访问来避免任何潜在的数据冲突， 这种数据冲突一般是由多线程异步访问相同的内存而引起的。</p>
<p>注意不要过度使用零拷贝内存。 由于其延迟较高， 从零拷贝内存中读取设备核函数可能很慢。</p>
<h4 id="425-统一虚拟寻址">4.2.5 统一虚拟寻址<a hidden class="anchor" aria-hidden="true" href="#425-统一虚拟寻址">#</a></h4>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch05/">
    <span class="title"><i class="fas fa-angle-double-left"></i> Prev Page</span>
    <br>
    <span>CUDA_C_CH05</span>
  </a>
  <a class="next" href="https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_c_notes/cuda_c_ch03/">
    <span class="title">Next Page <i class="fas fa-angle-double-right"></i></span>
    <br>
    <span>CUDA_C_CH03</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share CUDA_C_CH04 on twitter"
        href="https://twitter.com/intent/tweet/?text=CUDA_C_CH04&amp;url=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fgpu_compute%2fcuda_c_notes%2fcuda_c_ch04%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share CUDA_C_CH04 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fgpu_compute%2fcuda_c_notes%2fcuda_c_ch04%2f&amp;title=CUDA_C_CH04&amp;summary=CUDA_C_CH04&amp;source=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fgpu_compute%2fcuda_c_notes%2fcuda_c_ch04%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share CUDA_C_CH04 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fgpu_compute%2fcuda_c_notes%2fcuda_c_ch04%2f&title=CUDA_C_CH04">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share CUDA_C_CH04 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fgpu_compute%2fcuda_c_notes%2fcuda_c_ch04%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share CUDA_C_CH04 on whatsapp"
        href="https://api.whatsapp.com/send?text=CUDA_C_CH04%20-%20https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fgpu_compute%2fcuda_c_notes%2fcuda_c_ch04%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share CUDA_C_CH04 on telegram"
        href="https://telegram.me/share/url?text=CUDA_C_CH04&amp;url=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fgpu_compute%2fcuda_c_notes%2fcuda_c_ch04%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>




<footer class="tc-container" id="comment">
    <div class="tc-title"><p class="c-title">Discussion</p></div>
    <div id="tcomments"></div>
</footer>
<script crossorigin="anonymous" src="/js/twikoo.min.b16100b7cf8a61759eab076a122482054e083087aad37c3be1fe2e293934dc34.js" integrity="sha256-sWEAt8&#43;KYXWeqwdqEiSCBU4IMIeq03w74f4uKTk03DQ="></script>
<script>
    twikoo.init({
        envId: 'https://my-repository-pink.vercel.app/',
        el: '#tcomments',
        region: 'ap-shanghai', 
        
        lang: 'zh-CN', 
    });
</script>

</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
