<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43;_basics | Jian&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="一.常考C&#43;&#43;基础概念 1.C&#43;&#43;三大特性（封装、继承、多态） 封装： 隐藏类的属性和实现细节，仅仅对外提供接口， 封装性实际上是由编译器去识别关键">
<meta name="author" content="Jian">
<link rel="canonical" href="https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-11-10_c&#43;&#43;_basics/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.1ea9c8832138446635789668415e5c75b8a534b191ee749a44f5ab404c9f27c2.css" integrity="sha256-HqnIgyE4RGY1eJZoQV5cdbilNLGR7nSaRPWrQEyfJ8I=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jianye0428.github.io/favicon/jian_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://jianye0428.github.io/favicon/jian_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jianye0428.github.io/favicon/jian_icon.png">
<link rel="apple-touch-icon" href="https://jianye0428.github.io/favicon/apple-touch-icon.png">
<link rel="mask-icon" href="https://jianye0428.github.io/favicon/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-11-10_c&#43;&#43;_basics/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<meta name="baidu-site-verification" content="code-9oLyeix0aK" />
<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4a41bf85d719f0e8c3165fc76904f546";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>



<script defer crossorigin="anonymous" src="/js/katex.min.8f5024e83d2055dd60e021751066111b0057e230db34911dd56242d67f0a4c86.js" integrity="sha256-j1Ak6D0gVd1g4CF1EGYRGwBX4jDbNJEd1WJC1n8KTIY="></script>


<script defer crossorigin="anonymous" src="/js/auto-render.min.b09accad850e4e87b8a2fc8b93fae790def79172b68de72fd777958c52e566ad.js" integrity="sha256-sJrMrYUOToe4ovyLk/rnkN73kXK2jecv13eVjFLlZq0="></script>

<script>
    
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });

    
    window.WebFontConfig = {
        custom: {
            families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7',
            'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script',
            'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3',
            'KaTeX_Size4', 'KaTeX_Typewriter'],
        },
    };
</script>


<script defer crossorigin="anonymous" src="/js/webfontloader.min.min.d1c6c39d18e2decb5c99dc9efc579098ab37b9654725df3f9c0737bc2dd00760.js" integrity="sha256-0cbDnRji3stcmdye/FeQmKs3uWVHJd8/nAc3vC3QB2A="></script>


 

<script async src="https://www.googletagmanager.com/gtag/js?id=G-C6GDZ56F4S"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-C6GDZ56F4S', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="C&#43;&#43;_basics" />
<meta property="og:description" content="一.常考C&#43;&#43;基础概念 1.C&#43;&#43;三大特性（封装、继承、多态） 封装： 隐藏类的属性和实现细节，仅仅对外提供接口， 封装性实际上是由编译器去识别关键" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-11-10_c&#43;&#43;_basics/" /><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-09T19:52:47&#43;08:00" />
<meta property="article:modified_time" content="2022-11-09T19:52:47&#43;08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"/>

<meta name="twitter:title" content="C&#43;&#43;_basics"/>
<meta name="twitter:description" content="一.常考C&#43;&#43;基础概念 1.C&#43;&#43;三大特性（封装、继承、多态） 封装： 隐藏类的属性和实现细节，仅仅对外提供接口， 封装性实际上是由编译器去识别关键"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jianye0428.github.io/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "C++_basics",
      "item": "https://jianye0428.github.io/en/posts/notes/c++/2022-11-10_c++_basics/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++_basics",
  "name": "C\u002b\u002b_basics",
  "description": "一.常考C++基础概念 1.C++三大特性（封装、继承、多态） 封装： 隐藏类的属性和实现细节，仅仅对外提供接口， 封装性实际上是由编译器去识别关键",
  "keywords": [
    
  ],
  "articleBody": "一.常考C++基础概念 1.C++三大特性（封装、继承、多态） 封装：\n隐藏类的属性和实现细节，仅仅对外提供接口， 封装性实际上是由编译器去识别关键字public、private和protected来实现的， 体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。 私有成员是在封装体内被隐藏的部分，只有类体内声明的函数(类的成员函数)才可以访问私有成员， 而在类体外的函数是不能访问的，公有成员(public)是封装体与外界的一个接口， 类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和该类的派生类才可以访问的。\n优点：隔离变化；便于使用；提高重用性；提高安全性 缺点：如果封装太多，影响效率；使用者不能知道代码具体实现。\n继承：\n被继承的是父类（基类），继承出来的是子类（派生类），子类拥有父类的所有的特性。 继承方式有公有继承、私有继承，保护继承。默认是私有继承\n*公有继承中父类的公有和保护成员在子类中不变，私有的在子类中不可访问。 *私有继承中父类的公有和保护成员在子类中变为私有，但私有的在子类中不可访问。 *保护继承中父类的公有和保护成员在子类中变为保护，但私有的在子类中不可访问。 c++语言允许单继承和多继承\n优点：继承减少了重复的代码、继承是多态的前提、继承增加了类的耦合性； 缺点：继承在编译时刻就定义了，无法在运行时刻改变父类继承的实现；\n父类通常至少定义了子类的部分行为，父类的改变都可能影响子类的行为； 如果继承下来的子类不适合解决新问题，父类必须重写或替换，那么这种依赖关系就限制了灵活性， 最终限制了复用性。\n虚继承：为了解决多重继承中的二义性问题，它维护了一张虚基类表。 (菱形继承问题)\n多态:\nref: 多态的四种表现形式\n运行时多态(虚函数) 编译时多态(模板) 重载 类型转换 运行时多态(Subtype Polymorphism/Runtime Polymorphism)\n运行时多态就是派生类重写基类的虚函数，在调用函数里，参数为基类的指针或引用，会构成多态。我之前写过一篇多态的原理，就是在讲多态(运行时多态)在底层是怎么实现的 多态的底层实现\n举个例子：比如买票这个行为，成人去买就是全价，学生买就是半价票。但是不管成人还是学生都是人这个体系。所以我们需要根据谁来买票才能决定价格，这个时候就需要多态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include class ticket { public: virtual void price() = 0; }; class adult : public ticket { public: virtual void price() override { std::cout \u003c\u003c \"成人全价！\" \u003c\u003c std::endl; } }; class student : public ticket { public: virtual void price() override { std::cout \u003c\u003c \"学生半价！\" \u003c\u003c std::endl; } }; void BuyTicket(ticket\u0026 t) { t.price(); } int main(void) { adult a; student s; BuyTicket(a); BuyTicket(s); return 0; } 编译时多态(Parametric Polymorphism/Compile-Time Polymorphism)\n编译时多态就是模板。在程序编译时，编译器根据参数的类型，就将生成某种类型的函数或类。我之前关于模板的(总结)[https://blog.csdn.net/weixin_42678507/article/details/88658291]\n举个简单的例子：Add() 函数是一个非常简单的函数，但是如果你写一个整型的 Add 函数，那么我想加 double 型的呢？你再写一个 double 型的 Add 函数，那么我想加 char 型的呢？\n这个时候就用到了模板，我们先定义一个逻辑，具体类型等编译时再生成该类型的函数或类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include template\u003cclass T\u003e T Add(T lhs, T rhs) { return lhs + rhs; } int main(void) { Add(1, 2); Add(2.0, 3.0); Add('a', 'b'); return 0; } 重载(Ad-hoc Polymorphism/Overloading)\n函数名相同，参数不同就构成了重载。重载主要用于函数，当某个函数的功能无法处理某些参数的情况时，我们就可以重载一个函数来单独处理。\n举个例子：比如说上面的 Add 函数，当前内置类型都可以处理，但是如果我传两个字符串怎么办？就不可以像刚才那么加了。得重载一个函数单独处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include #include int Add(int lhs, int rhs) { return lhs + rhs; } std::string Add(const std::string\u0026 lhs, const std::string\u0026 rhs) { std::string ans(lhs); ans += rhs; return ans; } int main(void) { Add(1, 2); Add(\"abc\", \"def\"); return 0; } 类型转换(Coercion Polymorphism/Casting)\n类型转换主要分为四种：\nstatic_cast: 相当于隐式类型转换。 const_cast: 这个可以去除一个 const 变量的 const 性质，使可以改变它的值。 reinterpret_cast: 相当于强制类型转换。 dynamic_cast: 这个可以使子类指针或引用赋值给父类指针或引用。 类型转换很简单，这里就不多赘述了。\n2.数组和链表的区别 数组和链表是两种不同的数据存储方式\n数组的定义\n数组是一组具有相同数据类型的变量的集合，这些变量称之为集合的元素。 每个元素都有一个编号，称之为下标，可以通过下标来区别并访问数组元素，数组元素的个数叫做数据的长度。\n链表的定义\n链表是一种物理存储单元上非连续、非顺序的存储结构,数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表的特性是在中间任意位置插入和删除元素都非常快，不需要移动其它元素。 对于单向链表而言，链表中的每一个元素都要保存一个指向下一个元素的指针。 对于双向链表而言，链表中的每个元素既要保存指向下一个元素的指针，又要保存指向上一个元素的指针。 对于双向循环链表而言，链表中的最后一个元素保存一个指向第一个元素的指针。\n数组和链表的区别主要表现在以下几个方面\n比较 数组 链表 逻辑结构 (1) 数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小； (3) 数组元素增加时，有可能会数组越界； (4) 数组元素减少时，会造成内存浪费； （5）数组增删时需要移动其它元素 (1) 链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素 (3) 需要时可以使用malloc或者new来申请内存，不用时使用free或者delete来释放内存 内存结构 数组从栈上分配内存，使用方便，但是自由度小 链表从堆上分配内存，自由度大，但是要注意内存泄漏 访问效率 数组在内存中顺序存储，可通过下标访问，访问效率高 链表访问效率低，如果想要访问某个元素，需要从头遍历 越界问题 数组的大小是固定的，所以存在访问越界的风险 越界的风险\t只要可以申请得到链表空间，链表就无越界风险 数组和链表的使用场景\n比较 数组使用场景 链表使用场景 空间 数组的存储空间是栈上分配的，存储密度大，当要求存储的大小变化不大时，且可以事先确定大小，宜采用数组存储数据 链表的存储空间是堆上动态申请的，当要求存储的长度变化较大时，且事先无法估量数据规模，宜采用链表存储 时间 数组访问效率高。当线性表的操作主要是进行查找，很少插入和删除时，宜采用数组结构 链表插入、删除效率高，当线性表要求频繁插入和删除时，宜采用链表结构 3. 智能指针 我们知道除了静态内存和栈内存外，每个程序还有一个内存池，这部分内存被称为自由空间或者堆。程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。\n在C++中，动态内存的管理是用一对运算符完成的：new和delete，new:在动态内存中为对象分配一块空间并返回一个指向该对象的指针，delete：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。\n动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。\n为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。标准库提供的两种智能指针的区别在于管理底层指针的方法不同，shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。\n1 智能指针的作用\n智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源 2 智能指针的种类: shared_ptr、unique_ptr、weak_ptr、auto_ptr\n四种指针详情 2.1 智能指针的实现原理\n智能指针的实现原理就是在一个类的内部封装了类对象的指针，然后在析构函数里对我们的类对象指针进行释放，因为类的析构是在类对象生命期结束时自动调用的，这样我们就省去了手动释放内存的操作，避免忘记手动释放导致的内存泄漏。\n2.2 C++11四种智能指针总结\n2.2.1 auto_ptr：\nauto_ptr以前是用在C98中，C++11被抛弃，头文件一般用来作为独占指针 auto_ptr被赋值或者拷贝后，失去对原指针的管理 auto_ptr不能管理数组指针，因为auto_ptr的内部实现中，析构函数中删除对象使用delete而不是delete[]，释放内存的时候仅释放了数组的第一个元素的空间，会造成内存泄漏。 auto_ptr不能作为容器对象，因为STL容器中的元素经常要支持拷贝，赋值等操作。 2.2.2 unique_ptr:\nC++11中用来替代auto_ptr 拷贝构造和赋值运算符被禁用，不能进行拷贝构造和赋值运算 虽然禁用了拷贝构造和赋值运算符，但unique_ptr可以作为返回值，用于从某个函数中返回动态申请内存的所有权，本质上是移动拷贝，就是使用std:move()函数，将所有权转移。 2.2.3 share_ptr:\n多个指针可以指向相同的对象，调用release()计数-1，计数0时资源释放 .use_count()查计数 .reset()放弃内部所有权 share_ptr多次引用同一数据会导致内存多次释放 循环引用会导致死锁， 引用计数不是原子操作。 shared_ptr 有两个数据成员，一个是指向 对象的指针 ptr，另一个是 ref_count 指针（包含vptr、use_count、weak_count、ptr等）； 在这里插入图片描述 1 2 shared_ptr\u003cFoo\u003e x(new Foo); shared_ptr\u003cFoo\u003e y = x; 步骤一：\n`y=x` 涉及两个成员的复制，这两步拷贝不会同时（原子）发生，中间步骤 1，复制 ptr 指针，中间步骤 2，复制 ref_count 指针，导致引用计数加 1 步骤二: 因为是两步，如果没有 mutex 保护，那么在多线程里就有数据竞争。\n多线程读写同一个 shared_ptr 必须加锁。\n2.2.4 weak_ptr:\n1.解决两个share_ptr互相引用产生死锁，计数永远降不到0，没办法进行资源释放，造成内存泄漏的问题。 2.使用时配合share_ptr使用，把其中一个share_ptr更换为weak_ptr。 4. 重载、重写、重定义 (1) 重载（overload）： 指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。 a 相同的范围（在同一个类中） b 函数名字相同、 参数不同 c virtual关键字可有可无 d 返回值可以不同；\n(2) 重写（覆盖override)是指派生类函数覆盖基类函数，特征是： a 不同的范围，分别位于基类和派生类中 b 函数的名字相同、 参数相同 c 基类函数必须有virtual关键字，不能有static d 返回值相同（或者协变），否则报错； e 重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public, protected也是可以的\n(3) 重定义(隐藏redefine)是指派生类的函数屏蔽了与其同名的基类函数，特征是： a 不在同一个作用域（分别位于派生类与基类） b 函数名字相同 c 返回值可以不同 d 规则：\n如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏；\n如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。\nps: 多态性可以分为静态多态性（方法的重载，一个类）和动态多态性（方法的覆盖，有继承关系的类之间的行为）。进而多态性可以由重载和覆盖来实现。\n5.static与const区别和作用 static:\n1.**static局部变量**将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完不会释放，而是继续保留在内存中； 2.**static全局变量**表示一个变量在当前文件的全局可以访问； 3.**static函数**表示一个函数只能在当前文件中被访问； 4.**static类成员变量**表示这个成员为全类所共有； 5.**static类成员函数**表示这个函数为全类所有，且只能访问成员变量。 6.全局变量在整个工程文件内有效；静态全局变量只在定义它的文件中有效； 7.静态局部变量只在定义它的函数内有效，且程序只分配一次内存，函数返回时不会释放，下次调用时不会重新赋值，还保留上次结果值；局部变量在函数返回时就释放掉； 8.全局变量和静态变量编译器会默认初始化为0；局部变量的默认值未知； 9.局部静态变量与全局变量共享全局数据，但是静态局部变量值在定义该变量的函数内部可见。 10.静态成员（静态成员函数）与非静态成员（成员函数）的区别在于有无this指针；静态成员是静态存储，必须进行初始化； 11.静态成员函数访问非静态成员报错: 静态成员在类加载时就已经分配内存，而此时非静态成员尚未分配内存，访问不存在的内存自然会报错； const\n1.const常量 定义时必须初始化，以后不能修改； 2.const形参 该形参在函数里不能被修改； 3.const修饰类成员函数 该函数对成员变量只能进行读操作； static关键字作用\n1.函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此该值在下次调用时还维持上一次的值； 2.在模块内的static函数和变量可以被可以被模块内的函数访问，不能被模块外的函数访问； 3.在类内的static成员变量为整个类所有，类的所有对象只有一份拷贝； 4.在类内的static成员函数为整个类所有，这个函数不接收this指针，因此只能访问类的static成员变量； const关键字\n1.阻止一个变量被改变； 2.声明常量指针和指针常量； 3.const修饰形参，表示为输入参数，在函数体内不能修改该参数的值； 4.const修饰成员函数，表明为一个常函数，不能修改成员变量的值； 5.类的成员函数，有时必须返回const类型的值，使得返回值不能为左值。 const修饰指针有三种情况\nconst修饰指针 — 常量指针 (const修饰的是指针,指针指向可以改,指针指向的值不可以更改) 1 2 3 const int * p1 = \u0026a; p1 = \u0026b; //正确 //*p1 = 100; 报错 const修饰常量 — 指针常量 (const修饰的是常量,指针指向不可以改,指针指向的值可以更改) 1 2 3 int * const p2 = \u0026a; //p2 = \u0026b; //错误 *p2 = 100; //正确 const即修饰指针,又修饰常量 (const既修饰指针又修饰常量，都不可以改) 1 2 3 const int * const p3 = \u0026a; //p3 = \u0026b; //错误 //*p3 = 100; //错误 技巧:看const右侧紧跟着的是指针还是常量, 是指针就是常指针,是常量就是指针常量\n6. const与宏定义（#define）区别和作用 const 定义的是变量不是常量，只是这个变量的值不允许改变，是常变量，带有类型。编译运行的时候起作用，存在类型检查。\ndefine 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。\n1、两者的区别 (1) 编译器处理方式不同 #define 宏是在预处理阶段展开。 const 常量是编译运行阶段使用。\n(2) 类型和安全检查不同 #define 宏没有类型，不做任何类型检查，仅仅是展开。 const 常量有具体的类型，在编译阶段会执行类型检查。\n(3) 存储方式不同 #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。） const常量会在内存中分配(可以是堆中也可以是栈中)。\n(4) const 可以节省空间，避免不必要的内存分配。 例如： const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。\n(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。\n(6) 宏替换只作替换，不做计算，不做表达式求解;宏预编译时就替换了，程序运行时，并不分配内存。计算时注意边缘效应\n7.虚函数和纯虚函数区别 1.虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。 2.虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。 3.虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。 4.虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。 5.虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。 6.虚函数充分体现了面向对象思想中的继承和多态性这两大特性，在C++语言里应用极广。比如在微软的MFC类库中，你会发现很多函数都有virtual关键字，也就是说，它们都是虚函数。难怪有人甚至称虚函数是C++语言的精髓。 7.定义纯虚函数就是为了让基类不可实例化，因为实例化这样的抽象数据结构本身并没有意义或者给出实现也没有意义。 纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。\n虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现，这就像Java的接口一样。通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现\n虚函数: https://www.cnblogs.com/zkfopen/p/11061414.html\n8. 指针和引用的区别 1.指针和引用的定义和性质区别：\n(1) 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：\n1 2 3 int a=1;int *p=\u0026a; int a=1;int \u0026b=a; 上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。\n而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。\n(2)引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。\n(3)可以有const指针，但是没有const引用；\n(4)指针可以有多级，但是引用只能是一级（int **p；合法 而 int \u0026\u0026a是不合法的）\n(5)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；\n(6)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。\n(7)“sizeof引用\"得到的是所指向的变量(对象)的大小，而\"sizeof指针\"得到的是指针本身的大小；\n(8)指针和引用的自增(++)运算意义不一样；\n(9)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；\n9. 结构体赋值 (结构体赋值)[https://blog.csdn.net/datase/article/details/78988320]\n10. C和C++区别 (C和C++区别)[https://blog.csdn.net/czc1997/article/details/81254971]\n11. C和C++传参方式区别 C语言不支持引用传参，如果想要改变传入参数的值，只能用传入指针的方式。\n12. 深拷贝和浅拷贝区别 (深拷贝和浅拷贝区别)[https://blog.csdn.net/Situo/article/details/110225143]\n13. 避免头文件重复包含以及宏定义重定义 1 2 3 #ifndef LWIP_TCP_KEEPALIVE #define LWIP_TCP_KEEPALIVE #endif 14. 你怎么理解虚拟类？虚拟类可以实例化一个对象吗？为什么？它的作用和其他类的区别 答案：虚拟类可以派生对象，纯虚类不可以实例化对象。因为纯虚类存在未定义的函数，只是个概念，不可真实存在。虚拟类用做多态，纯虚类做接口。\n15. 内联函数怎么实现的，什么时期处理的，优缺点 答案：在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。 优点：不会产生函数调用的开销 缺点：增加目标程序的代码量，即增加空间开销\n16 .位运算（按位与、按位或、异或） 按位与运算符（\u0026）\n参加运算的两个数，按二进制位进行“与”运算。\n运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算）\n即 0 \u0026 0= 0 ，0 \u0026 1= 0，1 \u0026 0= 0， 1 \u0026 1= 1。\n例：3 \u00265 即 00000011 \u0026 00000101 = 00000001 ，所以 3 \u0026 5的值为1。\n按位或运算符（|）\n参加运算的两个数，按二进制位进行“或”运算。\n运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。\n即 0 | 0= 0 , 1 | 0= 1 ， 0 | 1= 1 , 1 | 1= 1 。\n例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。 异或运算符（^）\n参加运算的两个数，按二进制位进行“异或”运算。\n运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。\n即 0 ^ 0=0 ， 0 ^ 1= 1 ， 1 ^ 0= 1 ， 1 ^ 1= 0 。\n例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。\n17. 原码、反码、补码 原码：是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。\n反码：正数的反码还是等于原码 负数的反码就是他的原码除符号位外，按位取反。\n补码：正数的补码等于他的原码 负数的补码等于反码+1。\n18 . 堆和栈 (堆和栈)[https://blog.csdn.net/qq_45856289/article/details/106473750]\n19. 类和对象 面向对象(Object Oriented,OO)。\n起初，“面向对象”是指在程序设计中采用封装、继承、多态等设计方法。现在，面向对象的思想已经涉及到软件开发的各个方面。如，面向对象的分析（OOA，ObjectOriented Analysis），面向对象的设计（OOD，Object Oriented Design）、以及面向对象的编程实现（OOP，Object Oriented Programming）。 对象和类解释：\n1）对象：对象是人们要进行研究的任何事物，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。对象具有状态，一个对象用数据值来描述它的状态。对象还有操作，用于改变对象的状态，对象及其操作就是对象的行为。对象实现了数据和操作的结合，使数据和操作封装于对象的统一体中。\n2）类：具有相同特性（数据元素）和行为（功能）的对象的抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。类具有属性，它是对象的状态的抽象，用数据结构来描述类的属性。类具有操作，它是对象的行为的抽象，用操作名和实现该操作的方法来描述。 对象和类的关系：\n类与对象的关系就如模具和铸件的关系，类的实力化的结果就是对象，而对对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为的对象。\n20 . new和malloc区别 0.属性 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。\n1.参数 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。\n2.返回类型 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。 而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。\n3.分配失败 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。\n4.自定义类型 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。\n5.重载 C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。\n6.内存区域 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中\n21. 内核链表与双向循环链表 (内核链表与双向循环链表)[https://blog.csdn.net/liebao_han/article/details/53956609]\n22. 结构体和类的区别 1.结构体是一种值类型，而类是引用类型。值类型用于存储数据的值，引用类型用于存储对实际数据的引用。 那么结构体就是当成值来使用的，类则通过引用来对实际数据操作。\n结构体使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation) 栈的空间相对较小.但是存储在栈中的数据访问效率相对较高. 堆的空间相对较大.但是存储在堆中的数据的访问效率相对较低. 3.类是反映现实事物的一种抽象，而结构体的作用只是一种包含了具体不同类别数据的一种包装，结构体不具备类的继承多态特性\n4.结构体赋值是 直接赋值的值. 而对象的指针 赋值的是对象的地址\n5.Struct变量使用完之后就自动解除内存分配，Class实例有垃圾回收机制来保证内存的回收处理。\n6.结构体的构造函数中，必须为结构体所有字段赋值，类的构造函数无此限制\n首先,关于隐式构造函数.我们知道,在1个类中如果我们没有为类写任意的构造函数,那么C++编译器在编译的时候会自动的为这个类生成1个无参数的构造函数.我们将这个构造函数称之为隐式构造函数 但是一旦我们为这个类写了任意的1个构造函数的时候,这个隐式的构造函数就不会自动生成了.在结构体中,就不是这样了,在结构体中隐式的构造函数无论如何都存在。所以程序员不能手动的为结构添加1个无参数的构造函数。\n7.结构体中声明的字段无法赋予初值，类可以:\n如何选择结构体还是类\n1． 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些 2． 结构表示如点、矩形和颜色这样的轻量对象，例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。在此情况下，结构的成本较低。 3． 在表现抽象和多级别的对象层次时，类是最好的选择 4． 大多数情况下该类型只是一些数据时，结构时最佳的选择\n23. 结构体和联合体区别 两者最大的区别在于内存利用\n一、结构体struct\n各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。 二、联合体union\n各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。\n24. 结构体和枚举 一、结构体\n结构体:很像面向对象中的对象，但是结构体没有方法只有属性，一个结构体由不同类型的元素组成，而相较于数组来说，数组只能存储相同类型的元素。结构体占用的空间等于内部各元素占用空间的和，并且元素在内存中的地址（按照元素定义的顺序）是连续的。\n注意：结构体不能像面向对象中那样递归调用，自己包含自己，但是可以包含其他类型的结构体。\n二、枚举\n枚举:和面向对象中一样，枚举都是用来定义一些固定取值的常量,但是C中的枚举中的值是整数，默认按照0递增,也可以在定义枚举的时候赋值，那么后面的元素的值就会以这个元素为第一个元素递增\n25 . 数组和指针的区别与联系 (数组和指针的区别与联系)[https://blog.csdn.net/cherrydreamsover/article/details/81741459]\n26 . 函数指针\u0026指针函数 https://blog.csdn.net/baidu_37973494/article/details/83150266\n27 . const放在函数前后的区别 1、int GetY() const; 2、const int * GetPosition();\n对于1 该函数为只读函数，不允许修改其中的数据成员的值。\n对于2 修饰的是返回值，表示返回的是指针所指向值是常量\n28 . goto语句 goto语句也称为无条件转移语句，其一般格式如下： goto 语句标号； 其中语句标号是按标识符规定书写的符号， 放在某一语句行的前面，标号后加冒号(：)。语句标号起标识语句的作用，与goto 语句配合使用。举个例子：\n1 2 goto label; cout \u003c\u003c \"This is the\" 29 . extern关键字 1、extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。也就是说，在一个文件中定义了变量和函数， 在其他文件中要使用它们， 可以有两种方式：使用头文件，然后声明它们，然后其他文件去包含头文件；在其他文件中直接extern。\n2、extern C作用\n链接指示符extern C 如果程序员希望调用其他程序设计语言尤其是C 写的函数，那么调用函数时必须告诉编译器使用不同的要求，例如当这样的函数被调用时函数名或参数排列的顺序可能不同，无论是C++函数调用它还是用其他语言写的函数调用它，程序员用链接指示符告诉编译器该函数是用其他的程序设计语言编写的，链接指示符有两种形式既可以是单一语句形式也可以是复合语句形式。 // 单一语句形式的链接指示符 extern “C” void exit(int); // 复合语句形式的链接指示符 extern “C” { int printf( const char* … ); int scanf( const char* … ); } // 复合语句形式的链接指示符 extern “C” { #include } 链接指示符的第一种形式由关键字extern 后跟一个字符串常量以及一个普通的函数，声明构成虽然函数是用另外一种语言编写的但调用它仍然需要类型检查例如编译器会检查传递给函数exit()的实参的类型是否是int 或者能够隐式地转换成int 型，多个函数声明可以用花括号包含在链接指示符复合语句中，这是链接指示符的第二种形式花扩号被用作分割符表示链接指示符应用在哪些声明上在其他意义上该花括号被忽略，所以在花括号中声明的函数名对外是可见的就好像函数是在复合语句外声明的一样，例如在前面的例子中复合语句extern “C\"表示函数printf()和scanf()是在C 语言中写的，函数因此这个声明的意义就如同printf()和scanf()是在extern “C\"复合语句外面声明的一样，当复合语句链接指示符的括号中含有#include 时，在头文件中的函数声明都被假定是用链接指示符的程序设计语言所写的，在前面的例子中在头文件中声明的函数都是C函数链接指示符不能出现在函数体中下列代码段将会导致编译错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int main() { // 错误: 链接指示符不能出现在函数内 extern \"C\" double sqrt( double ); 305 第七章函数 double getValue(); //ok double result = sqrt ( getValue() ); //... return 0; } 如果把链接指示符移到函数体外程序编译将无错误 extern \"C\" double sqrt( double ); int main() { double getValue(); //ok double result = sqrt ( getValue() ); //... return 0; } 但是把链接指示符放在头文件中更合适，在那里函数声明描述了函数的接口所属，如果我们希望C++函数能够为C 程序所用又该怎么办呢我们也可以使用extern \"C\"链接指示符来使C++函数为C 程序可用例如。 // 函数calc() 可以被C 程序调用 extern \"C\" double calc( double dparm ) { /* ... */ } 如果一个函数在同一文件中不只被声明一次则链接指示符可以出现在每个声明中它，也可以只出现在函数的第一次声明中，在这种情况下第二个及以后的声明都接受第一个声明中链接指示符指定的链接规则例如 // ---- myMath.h ---- extern \"C\" double calc( double ); // ---- myMath.C ---- // 在Math.h 中的calc() 的声明 #include \"myMath.h\" // 定义了extern \"C\" calc() 函数 // calc() 可以从C 程序中被调用 double calc( double dparm ) { // ... 在本节中我们只看到为C 语言提供的链接指示extern \"C\"，extern \"C\"是惟一被保证由所有C++实现都支持的，每个编译器实现都可以为其环境下常用的语言提供其他链接指示例如extern \"Ada\"可以用来声明是用Ada 语言写的函数，extern \"FORTRAN\"用来声明是用FORTRAN 语言写的函数，等等因为其他的链接指示随着具体实现的不同而不同所以建议读者查看编译器的用户指南以获得其他链接指示符的进一步信息。 总结 extern “C” extern “C” 不但具有传统的声明外部变量的功能，还具有告知C++链接器使用C函数规范来链接的功能。 还具有告知C++编译器使用C规范来命名的功能。\n30 . 动态内存管理 (动态内存管理)[https://blog.csdn.net/zgege/article/details/82054076]\n31 .数组、链表、哈希、队列、栈数据结构特点，各自优点和缺点 数组(Array)： 优点：查询快，通过索引直接查找；有序添加，添加速度快，允许重复； 缺点：在中间部位添加、删除比较复杂，大小固定，只能存储一种类型的数据； 如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。\n链表(LinkedList)： 优点：有序添加、增删改速度快，对于链表数据结构，增加和删除只要修改元素中的指针就可以了； 缺点：查询慢，如果要访问链表中一个元素，就需要从第一个元素开始查找； 如果应用需要经常插入和删除元素，就应该用链表。\n栈(Stack)： 优点：提供后进先出的存储方式，添加速度快，允许重复； 缺点：只能在一头操作数据，存取其他项很慢；\n队列(Queue)： 优点：提供先进先出的存储方式，添加速度快，允许重复； 缺点：只能在一头添加，另一头获取，存取其他项很慢；\n哈希(Hash)： 特点：散列表，不允许重复； 优点：如果关键字已知则存取速度极快； 缺点：如果不知道关键字则存取很慢，对存储空间使用不充分；\n32. 友元函数 引入友元函数的原因 类具有封装、继承、多态、信息隐藏的特性，只有类的成员函数才可以访问类的私有成员，非成员函数只能访问类的公有成员。为了使类的非成员函数访问类的成员，唯一的做法就是将成员定义为public，但这样做会破坏信息隐藏的特性。基于以上原因，引入友元函数解决。 (友元函数)[https://blog.csdn.net/qq_26337701/article/details/53996104]\n33. 设计模式之单例模式、工厂模式、发布订阅模式以及观察者模式 (设计模式)[https://blog.csdn.net/m0_37322399/article/details/108515158]\n34. 构造函数： 什么是构造函数？\n通俗的讲，在类中，函数名和类名相同的函数称为构造函数。它的作用是在建立一个对象时，做某些初始化的工作（例如对数据赋予初值）。C++允许同名函数，也就允许在一个类中有多个构造函数。如果一个都没有，编译器将为该类产生一个默认的构造函数。\n构造函数上惟一的语法限制是它不能指定返回类型，甚至void 也不行。\n不带参数的构造函数：一般形式为 类名 对象名(){函数体}\n带参数的构造函数：不带参数的构造函数，只能以固定不变的值初始化对象。带参数构造函数的初始化要灵活的多，通过传递给构造函数的参数，可以赋予对象不同的初始值。一般形式为：构造函数名（形参表）；\n创建对象使用时：类名 对象名（实参表）；\n构造函数参数的初始值：构造函数的参数可以有缺省值。当定义对象时，如果不给出参数，就自动把相应的缺省参数值赋给对象。一般形式为： 构造函数名（参数=缺省值，参数=缺省值，……）; 析构函数：\n当一个类的对象离开作用域时，析构函数将被调用(系统自动调用)。析构函数的名字和类名一样，不过要在前面加上 ~ 。对一个类来说，只能允许一个析构函数，析构函数不能有参数，并且也没有返回值。析构函数的作用是完成一个清理工作，如释放从堆中分配的内存。\n一个类中可以有多个构造函数，但析构函数只能有一个。对象被析构的顺序，与其建立时的顺序相反，即后构造的对象先析构。 1、概念不同：\n析构函数：对象所在的函数已调用完毕时，系统自动执行析构函数。\n构造函数：是一种特殊的方法。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。 2、作用不同：\n析构函数：析构函数被调用。\n构造函数：为对象成员变量赋初始值 3、目的不同：\n析构函数：”清理善后” 的工作\n构造函数：主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。\n35. C++模板 https://blog.csdn.net/zhaizhaizhaiaaa/article/details/104091658\n36. C++ STL https://www.cnblogs.com/shiyangxt/archive/2008/09/11/1289493.html\nref: https://blog.csdn.net/qq_52621551/article/details/122960158\nc++ 八股文 关键字与运算符 1. 指针与引⽤ 指针：存放某个对象的地址，其本⾝就是变量（命了名的对象），本⾝就有地址，所以可以有指向指针的指针；可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变 (地址可变，地址存储的值也可变)\n引⽤：就是变量的别名，从⼀⽽终，不可变，必须初始化， 不存在指向空值的引⽤，但是存在指向空值的指针\n2. const 关键字 const的作⽤：被它修饰的值不能改变，是只读变量。必须在定义的时候就给它赋初值。\n顶层const: 表示指针本身是个常量 底层const: 表示指针所指的对象是一个常量\n2.1 常量指针（底层const）（指针指的对象不可改变）\n常量指针：是指定义了⼀个指针，这个指针指向⼀个只读的对象，不能通过常量指针来改变这个对象的值。常量指针强调的是指针对其所指对象的不可改变性。 特点：靠近变量名 形式:\nconst 数据类型 *指针变量 = 变量名 数据类型 const *指针变量 = 变量名 举例: 1 2 3 int temp = 10; const int* a = \u0026temp; int const *a = \u0026temp; 2.2 指针常量（顶层const）(指针不能改变) 指针常量：指针常量是指定义了⼀个指针，这个指针的值只能在定义时初始化，其他地⽅不能改变。指针常量强调的是指针的不可改变性。 特点: 靠近变量类型 形式: 数据类型 * const 指针变量=变量名\n实例: 1 int* const p = \u0026temp 3. define 和 typedef的区别 ",
  "wordCount" : "15527",
  "inLanguage": "en",
  "datePublished": "2022-11-09T19:52:47+08:00",
  "dateModified": "2022-11-09T19:52:47+08:00",
  "author":[{
    "@type": "Person",
    "name": "Jian"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jianye0428.github.io/en/posts/notes/c++/2022-11-10_c++_basics/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jian's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jianye0428.github.io/favicon/jian_icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jianye0428.github.io/en/" accesskey="h" title="Jian&#39;s Blog (Alt + H)">
                <img src="https://jianye0428.github.io/favicon/jian_icon.png" alt="logo" aria-label="logo"
                    height="30">Jian&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://jianye0428.github.io/cn/" title="Chinese"
                            aria-label="Chinese">Chinese</a>
                    </li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jianye0428.github.io/en/myresume/" title="My Resume">
                    <span>My Resume</span>
                </a>
            </li>
            <li>
                <a href="https://jianye0428.github.io/en/tags/" title="🔖Tags">
                    <span>🔖Tags</span>
                </a>
            </li>
            <li>
                <a href="https://jianye0428.github.io/en/archives" title="🙋🏻‍♂️Archive">
                    <span>🙋🏻‍♂️Archive</span>
                </a>
            </li>
            <li>
                <a href="https://jianye0428.github.io/en/search/" title="🔍Search (Alt &#43; /)" accesskey=/>
                    <span>🔍Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jianye0428.github.io/en/">Home</a>&nbsp;»&nbsp;<a href="https://jianye0428.github.io/en/posts/">Posts</a></div>
    <h1 class="post-title">
      C&#43;&#43;_basics
    </h1>
    <div class="post-meta"><span title='2022-11-09 19:52:47 +0800 CST'>2022-11-09</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Jian&nbsp;|&nbsp;<a href="https://github.com/jianye0428/myblog/tree/main/content/posts/notes/C&#43;&#43;/2022-11-10_c&#43;&#43;_basics.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e4%b8%80%e5%b8%b8%e8%80%83c%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5" aria-label="一.常考C&#43;&#43;基础概念">一.常考C++基础概念</a><ul>
                            
                    <li>
                        <a href="#1c%e4%b8%89%e5%a4%a7%e7%89%b9%e6%80%a7%e5%b0%81%e8%a3%85%e7%bb%a7%e6%89%bf%e5%a4%9a%e6%80%81" aria-label="1.C&#43;&#43;三大特性（封装、继承、多态）">1.C++三大特性（封装、继承、多态）</a></li>
                    <li>
                        <a href="#2%e6%95%b0%e7%bb%84%e5%92%8c%e9%93%be%e8%a1%a8%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="2.数组和链表的区别">2.数组和链表的区别</a></li>
                    <li>
                        <a href="#3-%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" aria-label="3. 智能指针">3. 智能指针</a></li>
                    <li>
                        <a href="#4-%e9%87%8d%e8%bd%bd%e9%87%8d%e5%86%99%e9%87%8d%e5%ae%9a%e4%b9%89" aria-label="4. 重载、重写、重定义">4. 重载、重写、重定义</a></li>
                    <li>
                        <a href="#5static%e4%b8%8econst%e5%8c%ba%e5%88%ab%e5%92%8c%e4%bd%9c%e7%94%a8" aria-label="5.static与const区别和作用">5.static与const区别和作用</a></li>
                    <li>
                        <a href="#6-const%e4%b8%8e%e5%ae%8f%e5%ae%9a%e4%b9%89define%e5%8c%ba%e5%88%ab%e5%92%8c%e4%bd%9c%e7%94%a8" aria-label="6. const与宏定义（#define）区别和作用">6. const与宏定义（#define）区别和作用</a></li>
                    <li>
                        <a href="#7%e8%99%9a%e5%87%bd%e6%95%b0%e5%92%8c%e7%ba%af%e8%99%9a%e5%87%bd%e6%95%b0%e5%8c%ba%e5%88%ab" aria-label="7.虚函数和纯虚函数区别">7.虚函数和纯虚函数区别</a></li>
                    <li>
                        <a href="#8-%e6%8c%87%e9%92%88%e5%92%8c%e5%bc%95%e7%94%a8%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="8. 指针和引用的区别">8. 指针和引用的区别</a></li>
                    <li>
                        <a href="#9-%e7%bb%93%e6%9e%84%e4%bd%93%e8%b5%8b%e5%80%bc" aria-label="9. 结构体赋值">9. 结构体赋值</a></li>
                    <li>
                        <a href="#10-c%e5%92%8cc%e5%8c%ba%e5%88%ab" aria-label="10. C和C&#43;&#43;区别">10. C和C++区别</a></li>
                    <li>
                        <a href="#11-c%e5%92%8cc%e4%bc%a0%e5%8f%82%e6%96%b9%e5%bc%8f%e5%8c%ba%e5%88%ab" aria-label="11. C和C&#43;&#43;传参方式区别">11. C和C++传参方式区别</a></li>
                    <li>
                        <a href="#12-%e6%b7%b1%e6%8b%b7%e8%b4%9d%e5%92%8c%e6%b5%85%e6%8b%b7%e8%b4%9d%e5%8c%ba%e5%88%ab" aria-label="12. 深拷贝和浅拷贝区别">12. 深拷贝和浅拷贝区别</a></li>
                    <li>
                        <a href="#13-%e9%81%bf%e5%85%8d%e5%a4%b4%e6%96%87%e4%bb%b6%e9%87%8d%e5%a4%8d%e5%8c%85%e5%90%ab%e4%bb%a5%e5%8f%8a%e5%ae%8f%e5%ae%9a%e4%b9%89%e9%87%8d%e5%ae%9a%e4%b9%89" aria-label="13. 避免头文件重复包含以及宏定义重定义">13. 避免头文件重复包含以及宏定义重定义</a></li>
                    <li>
                        <a href="#14-%e4%bd%a0%e6%80%8e%e4%b9%88%e7%90%86%e8%a7%a3%e8%99%9a%e6%8b%9f%e7%b1%bb%e8%99%9a%e6%8b%9f%e7%b1%bb%e5%8f%af%e4%bb%a5%e5%ae%9e%e4%be%8b%e5%8c%96%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e5%90%97%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ae%83%e7%9a%84%e4%bd%9c%e7%94%a8%e5%92%8c%e5%85%b6%e4%bb%96%e7%b1%bb%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="14. 你怎么理解虚拟类？虚拟类可以实例化一个对象吗？为什么？它的作用和其他类的区别">14. 你怎么理解虚拟类？虚拟类可以实例化一个对象吗？为什么？它的作用和其他类的区别</a></li>
                    <li>
                        <a href="#15-%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%bb%80%e4%b9%88%e6%97%b6%e6%9c%9f%e5%a4%84%e7%90%86%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="15. 内联函数怎么实现的，什么时期处理的，优缺点">15. 内联函数怎么实现的，什么时期处理的，优缺点</a></li>
                    <li>
                        <a href="#16-%e4%bd%8d%e8%bf%90%e7%ae%97%e6%8c%89%e4%bd%8d%e4%b8%8e%e6%8c%89%e4%bd%8d%e6%88%96%e5%bc%82%e6%88%96" aria-label="16 .位运算（按位与、按位或、异或）">16 .位运算（按位与、按位或、异或）</a></li>
                    <li>
                        <a href="#17-%e5%8e%9f%e7%a0%81%e5%8f%8d%e7%a0%81%e8%a1%a5%e7%a0%81" aria-label="17. 原码、反码、补码">17. 原码、反码、补码</a></li>
                    <li>
                        <a href="#18--%e5%a0%86%e5%92%8c%e6%a0%88" aria-label="18 . 堆和栈">18 . 堆和栈</a></li>
                    <li>
                        <a href="#19-%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1" aria-label="19. 类和对象">19. 类和对象</a></li>
                    <li>
                        <a href="#20--new%e5%92%8cmalloc%e5%8c%ba%e5%88%ab" aria-label="20 . new和malloc区别">20 . new和malloc区别</a></li>
                    <li>
                        <a href="#21-%e5%86%85%e6%a0%b8%e9%93%be%e8%a1%a8%e4%b8%8e%e5%8f%8c%e5%90%91%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8" aria-label="21. 内核链表与双向循环链表">21. 内核链表与双向循环链表</a></li>
                    <li>
                        <a href="#22-%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8c%e7%b1%bb%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="22. 结构体和类的区别">22. 结构体和类的区别</a></li>
                    <li>
                        <a href="#23-%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8c%e8%81%94%e5%90%88%e4%bd%93%e5%8c%ba%e5%88%ab" aria-label="23. 结构体和联合体区别">23. 结构体和联合体区别</a></li>
                    <li>
                        <a href="#24-%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8c%e6%9e%9a%e4%b8%be" aria-label="24. 结构体和枚举">24. 结构体和枚举</a></li>
                    <li>
                        <a href="#25--%e6%95%b0%e7%bb%84%e5%92%8c%e6%8c%87%e9%92%88%e7%9a%84%e5%8c%ba%e5%88%ab%e4%b8%8e%e8%81%94%e7%b3%bb" aria-label="25 . 数组和指针的区别与联系">25 . 数组和指针的区别与联系</a></li>
                    <li>
                        <a href="#26--%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88%e6%8c%87%e9%92%88%e5%87%bd%e6%95%b0" aria-label="26 . 函数指针&amp;amp;指针函数">26 . 函数指针&amp;指针函数</a></li>
                    <li>
                        <a href="#27--const%e6%94%be%e5%9c%a8%e5%87%bd%e6%95%b0%e5%89%8d%e5%90%8e%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="27 . const放在函数前后的区别">27 . const放在函数前后的区别</a></li>
                    <li>
                        <a href="#28--goto%e8%af%ad%e5%8f%a5" aria-label="28 . goto语句">28 . goto语句</a></li>
                    <li>
                        <a href="#29--extern%e5%85%b3%e9%94%ae%e5%ad%97" aria-label="29 . extern关键字">29 . extern关键字</a></li>
                    <li>
                        <a href="#30--%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="30 . 动态内存管理">30 . 动态内存管理</a></li>
                    <li>
                        <a href="#31-%e6%95%b0%e7%bb%84%e9%93%be%e8%a1%a8%e5%93%88%e5%b8%8c%e9%98%9f%e5%88%97%e6%a0%88%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%89%b9%e7%82%b9%e5%90%84%e8%87%aa%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9" aria-label="31 .数组、链表、哈希、队列、栈数据结构特点，各自优点和缺点">31 .数组、链表、哈希、队列、栈数据结构特点，各自优点和缺点</a></li>
                    <li>
                        <a href="#32-%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0" aria-label="32. 友元函数">32. 友元函数</a></li>
                    <li>
                        <a href="#33-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e4%b9%8b%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f%e4%bb%a5%e5%8f%8a%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f" aria-label="33. 设计模式之单例模式、工厂模式、发布订阅模式以及观察者模式">33. 设计模式之单例模式、工厂模式、发布订阅模式以及观察者模式</a></li>
                    <li>
                        <a href="#34-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" aria-label="34. 构造函数：">34. 构造函数：</a></li>
                    <li>
                        <a href="#35-c%e6%a8%a1%e6%9d%bf" aria-label="35. C&#43;&#43;模板">35. C++模板</a></li>
                    <li>
                        <a href="#36-c-stl" aria-label="36. C&#43;&#43; STL">36. C++ STL</a></li></ul>
                    </li>
                    <li>
                        <a href="#c-%e5%85%ab%e8%82%a1%e6%96%87" aria-label="c&#43;&#43; 八股文">c++ 八股文</a><ul>
                            
                    <li>
                        <a href="#%e5%85%b3%e9%94%ae%e5%ad%97%e4%b8%8e%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="关键字与运算符">关键字与运算符</a><ul>
                            
                    <li>
                        <a href="#1-%e6%8c%87%e9%92%88%e4%b8%8e%e5%bc%95" aria-label="1. 指针与引⽤">1. 指针与引⽤</a></li>
                    <li>
                        <a href="#2-const-%e5%85%b3%e9%94%ae%e5%ad%97" aria-label="2. const 关键字">2. const 关键字</a></li>
                    <li>
                        <a href="#3-define-%e5%92%8c-typedef%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="3. define 和 typedef的区别">3. define 和 typedef的区别</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="一常考c基础概念">一.常考C++基础概念<a hidden class="anchor" aria-hidden="true" href="#一常考c基础概念">#</a></h2>
<h3 id="1c三大特性封装继承多态">1.C++三大特性（封装、继承、多态）<a hidden class="anchor" aria-hidden="true" href="#1c三大特性封装继承多态">#</a></h3>
<p><strong>封装：</strong></p>
<blockquote>
<p>隐藏类的属性和实现细节，仅仅对外提供接口，
封装性实际上是由编译器去识别关键字public、private和protected来实现的，
体现在类的成员可以有<font color=red>公有成员(public)</font>，<font color=red>私有成员(private)</font>，<font color=red>保护成员(protected)</font>。
私有成员是在封装体内被隐藏的部分，只有类体内声明的函数(类的成员函数)才可以访问私有成员，
而在类体外的函数是不能访问的，<u>公有成员(public)是封装体与外界的一个接口</u>，
类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和<strong>该类的派生类</strong>才可以访问的。</p>
</blockquote>
<blockquote>
<p>优点：隔离变化；便于使用；提高重用性；提高安全性
缺点：如果封装太多，影响效率；使用者不能知道代码具体实现。</p>
</blockquote>
<p><strong>继承：</strong></p>
<blockquote>
<p>被继承的是父类（基类），继承出来的是子类（派生类），子类拥有父类的所有的特性。
继承方式有<font color=red>公有继承</font>、<font color=red>私有继承</font>，<font color=red>保护继承</font>。默认是<strong>私有继承</strong></p>
</blockquote>
<blockquote>
<p>*公有继承中父类的公有和保护成员在子类中不变，私有的在子类中不可访问。
*私有继承中父类的公有和保护成员在子类中变为私有，但私有的在子类中不可访问。
*保护继承中父类的公有和保护成员在子类中变为保护，但私有的在子类中不可访问。
c++语言允许单继承和多继承</p>
</blockquote>
<blockquote>
<p>优点：继承减少了重复的代码、继承是多态的前提、继承增加了类的耦合性；
缺点：继承在编译时刻就定义了，无法在运行时刻改变父类继承的实现；</p>
</blockquote>
<blockquote>
<p>父类通常至少定义了子类的部分行为，父类的改变都可能影响子类的行为；
如果继承下来的子类不适合解决新问题，父类必须重写或替换，那么这种依赖关系就限制了灵活性，
最终限制了复用性。</p>
</blockquote>
<blockquote>
<p>虚继承：为了解决多重继承中的二义性问题，它维护了一张虚基类表。 (菱形继承问题)</p>
</blockquote>
<p><strong>多态:</strong></p>
<p>ref: <a href="https://blog.csdn.net/weixin_42678507/article/details/97111466">多态的四种表现形式</a></p>
<ul>
<li>运行时多态(虚函数)</li>
<li>编译时多态(模板)</li>
<li>重载</li>
<li>类型转换</li>
</ul>
<blockquote>
<p>运行时多态(Subtype Polymorphism/Runtime Polymorphism)</p>
</blockquote>
<p>运行时多态就是派生类重写基类的虚函数，在调用函数里，参数为基类的指针或引用，会构成多态。我之前写过一篇多态的原理，就是在讲多态(运行时多态)在底层是怎么实现的
<a href="https://blog.csdn.net/weixin_42678507/article/details/89467387">多态的底层实现</a></p>
<p>举个例子：比如买票这个行为，成人去买就是全价，学生买就是半价票。但是不管成人还是学生都是人这个体系。所以我们需要根据谁来买票才能决定价格，这个时候就需要多态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ticket</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">price</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">adult</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ticket</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">price</span><span class="p">()</span> <span class="k">override</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;成人全价！&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">student</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ticket</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">price</span><span class="p">()</span> <span class="k">override</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;学生半价！&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">BuyTicket</span><span class="p">(</span><span class="n">ticket</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">t</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">adult</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">student</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">BuyTicket</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">BuyTicket</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>编译时多态(Parametric Polymorphism/Compile-Time Polymorphism)</p>
</blockquote>
<p>编译时多态就是模板。在程序编译时，编译器根据参数的类型，就将生成某种类型的函数或类。我之前关于模板的(总结)[https://blog.csdn.net/weixin_42678507/article/details/88658291]</p>
<p>举个简单的例子：Add() 函数是一个非常简单的函数，但是如果你写一个整型的 Add 函数，那么我想加 double 型的呢？你再写一个 double 型的 Add 函数，那么我想加 char 型的呢？</p>
<p>这个时候就用到了模板，我们先定义一个逻辑，具体类型等编译时再生成该类型的函数或类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">Add</span><span class="p">(</span><span class="n">T</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">T</span> <span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Add</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Add</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>重载(Ad-hoc Polymorphism/Overloading)</p>
</blockquote>
<p>函数名相同，参数不同就构成了重载。重载主要用于函数，当某个函数的功能无法处理某些参数的情况时，我们就可以重载一个函数来单独处理。</p>
<p>举个例子：比如说上面的 Add 函数，当前内置类型都可以处理，但是如果我传两个字符串怎么办？就不可以像刚才那么加了。得重载一个函数单独处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Add</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ans</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ans</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Add</span><span class="p">(</span><span class="s">&#34;abc&#34;</span><span class="p">,</span> <span class="s">&#34;def&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>类型转换(Coercion Polymorphism/Casting)</p>
</blockquote>
<p>类型转换主要分为四种：</p>
<ul>
<li>static_cast: 相当于隐式类型转换。</li>
<li>const_cast: 这个可以去除一个 const 变量的 const 性质，使可以改变它的值。</li>
<li>reinterpret_cast: 相当于强制类型转换。</li>
<li>dynamic_cast: 这个可以使子类指针或引用赋值给父类指针或引用。</li>
</ul>
<p>类型转换很简单，这里就不多赘述了。</p>
<h3 id="2数组和链表的区别">2.数组和链表的区别<a hidden class="anchor" aria-hidden="true" href="#2数组和链表的区别">#</a></h3>
<p>数组和链表是两种不同的数据存储方式</p>
<p><strong><font color=purple>数组的定义</font></strong></p>
<blockquote>
<p>数组是一组具有相同数据类型的变量的集合，这些变量称之为集合的元素。
每个元素都有一个编号，称之为下标，可以通过下标来区别并访问数组元素，数组元素的个数叫做数据的长度。</p>
</blockquote>
<p><strong><font color=purple>链表的定义</font></strong></p>
<blockquote>
<p>链表是一种<u>物理存储单元上非连续、非顺序的</u>存储结构,数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
链表的特性是在中间任意位置插入和删除元素都非常快，不需要移动其它元素。
对于单向链表而言，链表中的每一个元素都要保存一个指向下一个元素的指针。
对于双向链表而言，链表中的每个元素既要保存指向下一个元素的指针，又要保存指向上一个元素的指针。
对于双向循环链表而言，链表中的最后一个元素保存一个指向第一个元素的指针。</p>
</blockquote>
<p><strong><font color=purple>数组和链表的区别主要表现在以下几个方面</font></strong></p>
<table>
<thead>
<tr>
<th>比较</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑结构</td>
<td>(1) 数组在内存中连续；   (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；  (3) 数组元素增加时，有可能会数组越界；  (4) 数组元素减少时，会造成内存浪费；  （5）数组增删时需要移动其它元素</td>
<td>(1) 链表采用动态内存分配的方式，在内存中不连续   (2)支持动态增加或者删除元素   (3) 需要时可以使用malloc或者new来申请内存，不用时使用free或者delete来释放内存</td>
</tr>
<tr>
<td>内存结构</td>
<td>数组从栈上分配内存，使用方便，但是自由度小</td>
<td>链表从堆上分配内存，自由度大，但是要注意内存泄漏</td>
</tr>
<tr>
<td>访问效率</td>
<td>数组在内存中顺序存储，可通过下标访问，访问效率高</td>
<td>链表访问效率低，如果想要访问某个元素，需要从头遍历</td>
</tr>
<tr>
<td>越界问题</td>
<td>数组的大小是固定的，所以存在访问越界的风险</td>
<td>越界的风险	只要可以申请得到链表空间，链表就无越界风险</td>
</tr>
</tbody>
</table>
<p><strong><font color=purple>数组和链表的使用场景</font></strong></p>
<table>
<thead>
<tr>
<th>比较</th>
<th>数组使用场景</th>
<th>链表使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间</td>
<td>数组的存储空间是栈上分配的，存储密度大，当要求存储的大小变化不大时，且可以事先确定大小，宜采用数组存储数据</td>
<td>链表的存储空间是堆上动态申请的，当要求存储的长度变化较大时，且事先无法估量数据规模，宜采用链表存储</td>
</tr>
<tr>
<td>时间</td>
<td>数组访问效率高。当线性表的操作主要是进行查找，很少插入和删除时，宜采用数组结构</td>
<td>链表插入、删除效率高，当线性表要求频繁插入和删除时，宜采用链表结构</td>
</tr>
</tbody>
</table>
<h3 id="3-智能指针">3. 智能指针<a hidden class="anchor" aria-hidden="true" href="#3-智能指针">#</a></h3>
<p>我们知道除了静态内存和栈内存外，每个程序还有一个<strong>内存池</strong>，这部分内存被称为自由空间或者堆。程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。</p>
<p>在C++中，动态内存的管理是用一对运算符完成的：<strong>new</strong>和<strong>delete</strong>，new:在动态内存中为对象分配一块空间并返回一个指向该对象的指针，delete：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。</p>
<p>动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。</p>
<p>为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。标准库提供的两种智能指针的区别在于管理底层指针的方法不同，<strong>shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象</strong>。标准库还定义了一种名为<strong>weak_ptr的伴随类</strong>，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。</p>
<ul>
<li>
<p>1 智能指针的作用</p>
<ul>
<li>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源</li>
</ul>
</li>
<li>
<p>2  智能指针的种类: shared_ptr、unique_ptr、weak_ptr、auto_ptr</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_41969690/article/details/107912842">四种指针详情</a></li>
</ul>
</li>
</ul>
<p>2.1 智能指针的实现原理</p>
<p>智能指针的实现原理就是在一个类的内部封装了类对象的指针，然后在析构函数里对我们的类对象指针进行释放，因为类的析构是在类对象生命期结束时自动调用的，这样我们就省去了手动释放内存的操作，避免忘记手动释放导致的内存泄漏。</p>
<p>2.2 C++11四种智能指针总结</p>
<p>2.2.1 auto_ptr：</p>
<pre><code>auto_ptr以前是用在C98中，C++11被抛弃，头文件一般用来作为独占指针

auto_ptr被赋值或者拷贝后，失去对原指针的管理

auto_ptr不能管理数组指针，因为auto_ptr的内部实现中，析构函数中删除对象使用delete而不是delete[]，释放内存的时候仅释放了数组的第一个元素的空间，会造成内存泄漏。

auto_ptr不能作为容器对象，因为STL容器中的元素经常要支持拷贝，赋值等操作。
</code></pre>
<p>2.2.2 unique_ptr:</p>
<pre><code>C++11中用来替代auto_ptr

拷贝构造和赋值运算符被禁用，不能进行拷贝构造和赋值运算

虽然禁用了拷贝构造和赋值运算符，但unique_ptr可以作为返回值，用于从某个函数中返回动态申请内存的所有权，本质上是移动拷贝，就是使用std:move()函数，将所有权转移。
</code></pre>
<p>2.2.3 share_ptr:</p>
<pre><code>多个指针可以指向相同的对象，调用release()计数-1，计数0时资源释放

.use_count()查计数

.reset()放弃内部所有权

share_ptr多次引用同一数据会导致内存多次释放

循环引用会导致死锁，

引用计数不是原子操作。
</code></pre>
<p><code>shared_ptr</code> 有两个数据成员，一个是指向 对象的指针 ptr，另一个是 ref_count 指针（包含vptr、use_count、weak_count、ptr等）；
在这里插入图片描述
<img loading="lazy" src="https://github.com/jianye0428/hello-hugo/raw/master/img/posts/notes/c&#43;&#43;/2022-11-10_c&#43;&#43;_basics/2022-11-10_c&#43;&#43;_basics_shared_ptr.png#center" alt="shared ptr"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>步骤一：</p>
<pre><code>`y=x` 涉及两个成员的复制，这两步拷贝不会同时（原子）发生，中间步骤 1，复制 ptr 指针，中间步骤 2，复制 ref_count 指针，导致引用计数加 1
</code></pre>
<p><img loading="lazy" src="https://github.com/jianye0428/hello-hugo/raw/master/img/posts/notes/c&#43;&#43;/2022-11-10_c&#43;&#43;_basics/2022-11-10_c&#43;&#43;_basics_shared_ptr.png#center" alt="shared ptr"  />

步骤二:
<img loading="lazy" src="https://github.com/jianye0428/hello-hugo/raw/master/img/posts/notes/c&#43;&#43;/2022-11-10_c&#43;&#43;_basics/2022-11-10_c&#43;&#43;_basics_shared_ptr.png#center" alt="shared ptr"  />
</p>
<p>因为是两步，如果没有 <code>mutex</code> 保护，那么在多线程里就有数据竞争。</p>
<p>多线程读写同一个 <code>shared_ptr</code> 必须加锁。</p>
<p>2.2.4 weak_ptr:</p>
<pre><code>1.解决两个share_ptr互相引用产生死锁，计数永远降不到0，没办法进行资源释放，造成内存泄漏的问题。

2.使用时配合share_ptr使用，把其中一个share_ptr更换为weak_ptr。
</code></pre>
<h3 id="4-重载重写重定义">4. 重载、重写、重定义<a hidden class="anchor" aria-hidden="true" href="#4-重载重写重定义">#</a></h3>
<p>(1) 重载（overload）：
指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。
a 相同的范围（在同一个类中）
b 函数名字相同、 参数不同
c virtual关键字可有可无
d 返回值可以不同；</p>
<p>(2) 重写（覆盖override)是指派生类函数覆盖基类函数，特征是：
a 不同的范围，分别位于基类和派生类中
b 函数的名字相同、 参数相同
c 基类函数必须有virtual关键字，不能有static
d 返回值相同（或者协变），否则报错；
e 重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public, protected也是可以的</p>
<p>(3) 重定义(隐藏redefine)是指派生类的函数屏蔽了与其同名的基类函数，特征是：
a 不在同一个作用域（分别位于派生类与基类）
b 函数名字相同
c 返回值可以不同
d 规则：</p>
<p>如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏；</p>
<p>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。</p>
<p>ps: 多态性可以分为静态多态性（方法的重载，一个类）和动态多态性（方法的覆盖，有继承关系的类之间的行为）。进而多态性可以由重载和覆盖来实现。</p>
<h3 id="5static与const区别和作用">5.static与const区别和作用<a hidden class="anchor" aria-hidden="true" href="#5static与const区别和作用">#</a></h3>
<p>static:</p>
<pre><code>1.**static局部变量**将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完不会释放，而是继续保留在内存中；
2.**static全局变量**表示一个变量在当前文件的全局可以访问；
3.**static函数**表示一个函数只能在当前文件中被访问；
4.**static类成员变量**表示这个成员为全类所共有；
5.**static类成员函数**表示这个函数为全类所有，且只能访问成员变量。
6.全局变量在整个工程文件内有效；静态全局变量只在定义它的文件中有效；
7.静态局部变量只在定义它的函数内有效，且程序只分配一次内存，函数返回时不会释放，下次调用时不会重新赋值，还保留上次结果值；局部变量在函数返回时就释放掉；
8.全局变量和静态变量编译器会默认初始化为0；局部变量的默认值未知；
9.局部静态变量与全局变量共享全局数据，但是静态局部变量值在定义该变量的函数内部可见。
10.静态成员（静态成员函数）与非静态成员（成员函数）的区别在于有无this指针；静态成员是静态存储，必须进行初始化；
11.静态成员函数访问非静态成员报错: 静态成员在类加载时就已经分配内存，而此时非静态成员尚未分配内存，访问不存在的内存自然会报错；
</code></pre>
<p>const</p>
<pre><code>1.&lt;font color=red&gt;const常量&lt;/font&gt; 定义时必须初始化，以后不能修改；
2.&lt;font color=red&gt;const形参&lt;/font&gt; 该形参在函数里不能被修改；
3.&lt;font color=red&gt;const修饰类成员函数&lt;/font&gt; 该函数对成员变量只能进行读操作；
</code></pre>
<p>static关键字作用</p>
<pre><code>1.函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此该值在下次调用时还维持上一次的值；
2.在模块内的static函数和变量可以被可以被模块内的函数访问，不能被模块外的函数访问；
3.在类内的static成员变量为整个类所有，类的所有对象只有一份拷贝；
4.在类内的static成员函数为整个类所有，这个函数不接收this指针，因此只能访问类的static成员变量；
</code></pre>
<p>const关键字</p>
<pre><code>1.阻止一个变量被改变；
2.声明常量指针和指针常量；
3.const修饰形参，表示为输入参数，在函数体内不能修改该参数的值；
4.const修饰成员函数，表明为一个常函数，不能修改成员变量的值；
5.类的成员函数，有时必须返回const类型的值，使得返回值不能为左值。
</code></pre>
<p><strong>const修饰指针有三种情况</strong></p>
<ol>
<li>const修饰指针 &mdash; 常量指针 (const修饰的是指针,指针指向可以改,指针指向的值不可以更改)</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span> <span class="c1">//正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//*p1 = 100; 报错
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>const修饰常量 &mdash; 指针常量 (const修饰的是常量,指针指向不可以改,指针指向的值可以更改)</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//p2 = &amp;b; //错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//正确
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>const即修饰指针,又修饰常量 (const既修饰指针又修饰常量，都不可以改)</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">p3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//p3 = &amp;b; //错误
</span></span></span><span class="line"><span class="cl"><span class="c1">//*p3 = 100; //错误
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>技巧:看const右侧紧跟着的是指针还是常量, 是指针就是常指针,是常量就是指针常量</p>
<h3 id="6-const与宏定义define区别和作用">6. const与宏定义（#define）区别和作用<a hidden class="anchor" aria-hidden="true" href="#6-const与宏定义define区别和作用">#</a></h3>
<p>const 定义的是变量不是常量，只是这个变量的值不允许改变，是常变量，带有类型。编译运行的时候起作用，存在类型检查。</p>
<p>define 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。</p>
<p>1、两者的区别
(1) 编译器处理方式不同
#define 宏是在预处理阶段展开。
const 常量是编译运行阶段使用。</p>
<p>(2) 类型和安全检查不同
#define 宏没有类型，不做任何类型检查，仅仅是展开。
const 常量有具体的类型，在编译阶段会执行类型检查。</p>
<p>(3) 存储方式不同
#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
const常量会在内存中分配(可以是堆中也可以是栈中)。</p>
<p>(4) const 可以节省空间，避免不必要的内存分配。 例如：
const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。</p>
<p>(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</p>
<p>(6) 宏替换只作替换，不做计算，不做表达式求解;宏预编译时就替换了，程序运行时，并不分配内存。计算时注意边缘效应</p>
<h3 id="7虚函数和纯虚函数区别">7.虚函数和纯虚函数区别<a hidden class="anchor" aria-hidden="true" href="#7虚函数和纯虚函数区别">#</a></h3>
<pre><code>1.虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。
2.虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。
3.虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。
4.虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。
5.虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual  { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。
6.虚函数充分体现了面向对象思想中的继承和多态性这两大特性，在C++语言里应用极广。比如在微软的MFC类库中，你会发现很多函数都有virtual关键字，也就是说，它们都是虚函数。难怪有人甚至称虚函数是C++语言的精髓。
7.定义纯虚函数就是为了让基类不可实例化，因为实例化这样的抽象数据结构本身并没有意义或者给出实现也没有意义。
</code></pre>
<p><font color=purple>纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</font></p>
<p>虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现，这就像Java的接口一样。通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现</p>
<p>虚函数: <a href="https://www.cnblogs.com/zkfopen/p/11061414.html">https://www.cnblogs.com/zkfopen/p/11061414.html</a></p>
<h3 id="8-指针和引用的区别">8. 指针和引用的区别<a hidden class="anchor" aria-hidden="true" href="#8-指针和引用的区别">#</a></h3>
<p>1.指针和引用的定义和性质区别：</p>
<p>(1) 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。</p>
<p>而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。</p>
<p>(2)引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。</p>
<p>(3)可以有const指针，但是没有const引用；</p>
<p>(4)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</p>
<p>(5)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；</p>
<p>(6)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。</p>
<p>(7)&ldquo;sizeof引用&quot;得到的是所指向的变量(对象)的大小，而&quot;sizeof指针&quot;得到的是指针本身的大小；</p>
<p>(8)指针和引用的自增(++)运算意义不一样；</p>
<p>(9)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；</p>
<h3 id="9-结构体赋值">9. 结构体赋值<a hidden class="anchor" aria-hidden="true" href="#9-结构体赋值">#</a></h3>
<p>(结构体赋值)[https://blog.csdn.net/datase/article/details/78988320]</p>
<h3 id="10-c和c区别">10. C和C++区别<a hidden class="anchor" aria-hidden="true" href="#10-c和c区别">#</a></h3>
<p>(C和C++区别)[https://blog.csdn.net/czc1997/article/details/81254971]</p>
<h3 id="11-c和c传参方式区别">11. C和C++传参方式区别<a hidden class="anchor" aria-hidden="true" href="#11-c和c传参方式区别">#</a></h3>
<p>C语言不支持引用传参，如果想要改变传入参数的值，只能用传入指针的方式。</p>
<h3 id="12-深拷贝和浅拷贝区别">12. 深拷贝和浅拷贝区别<a hidden class="anchor" aria-hidden="true" href="#12-深拷贝和浅拷贝区别">#</a></h3>
<p>(深拷贝和浅拷贝区别)[https://blog.csdn.net/Situo/article/details/110225143]</p>
<h3 id="13-避免头文件重复包含以及宏定义重定义">13. 避免头文件重复包含以及宏定义重定义<a hidden class="anchor" aria-hidden="true" href="#13-避免头文件重复包含以及宏定义重定义">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef LWIP_TCP_KEEPALIVE
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LWIP_TCP_KEEPALIVE
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="14-你怎么理解虚拟类虚拟类可以实例化一个对象吗为什么它的作用和其他类的区别">14. 你怎么理解虚拟类？虚拟类可以实例化一个对象吗？为什么？它的作用和其他类的区别<a hidden class="anchor" aria-hidden="true" href="#14-你怎么理解虚拟类虚拟类可以实例化一个对象吗为什么它的作用和其他类的区别">#</a></h3>
<p>答案：虚拟类可以派生对象，纯虚类不可以实例化对象。因为纯虚类存在未定义的函数，只是个概念，不可真实存在。虚拟类用做多态，纯虚类做接口。</p>
<h3 id="15-内联函数怎么实现的什么时期处理的优缺点">15. 内联函数怎么实现的，什么时期处理的，优缺点<a hidden class="anchor" aria-hidden="true" href="#15-内联函数怎么实现的什么时期处理的优缺点">#</a></h3>
<p>答案：在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。
优点：不会产生函数调用的开销
缺点：增加目标程序的代码量，即增加空间开销</p>
<h3 id="16-位运算按位与按位或异或">16 .位运算（按位与、按位或、异或）<a hidden class="anchor" aria-hidden="true" href="#16-位运算按位与按位或异或">#</a></h3>
<p>按位与运算符（&amp;）</p>
<p>参加运算的两个数，按二进制位进行“与”运算。</p>
<p>运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算）</p>
<p>即 0 &amp; 0= 0 ，0 &amp; 1= 0，1 &amp; 0= 0， 1 &amp; 1= 1。</p>
<p>例：3 &amp;5  即 00000011 &amp; 00000101 = 00000001 ，所以 3 &amp; 5的值为1。</p>
<p>按位或运算符（|）</p>
<p>参加运算的两个数，按二进制位进行“或”运算。</p>
<p>运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。</p>
<p>即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 。</p>
<p>例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。
异或运算符（^）</p>
<p>参加运算的两个数，按二进制位进行“异或”运算。</p>
<p>运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p>
<p>即 0 ^ 0=0  ， 0 ^ 1= 1  ， 1 ^ 0= 1  ， 1 ^ 1= 0 。</p>
<p>例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。</p>
<h3 id="17-原码反码补码">17. 原码、反码、补码<a hidden class="anchor" aria-hidden="true" href="#17-原码反码补码">#</a></h3>
<blockquote>
<p>原码：是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。</p>
</blockquote>
<blockquote>
<p>反码：正数的反码还是等于原码
负数的反码就是他的原码除符号位外，按位取反。</p>
</blockquote>
<blockquote>
<p>补码：正数的补码等于他的原码
负数的补码等于反码+1。</p>
</blockquote>
<h3 id="18--堆和栈">18 . 堆和栈<a hidden class="anchor" aria-hidden="true" href="#18--堆和栈">#</a></h3>
<p>(堆和栈)[https://blog.csdn.net/qq_45856289/article/details/106473750]</p>
<h3 id="19-类和对象">19. 类和对象<a hidden class="anchor" aria-hidden="true" href="#19-类和对象">#</a></h3>
<p>面向对象(Object Oriented,OO)。</p>
<p>起初，“面向对象”是指在程序设计中采用封装、继承、多态等设计方法。现在，面向对象的思想已经涉及到软件开发的各个方面。如，面向对象的分析（OOA，ObjectOriented Analysis），面向对象的设计（OOD，Object Oriented Design）、以及面向对象的编程实现（OOP，Object Oriented Programming）。
对象和类解释：</p>
<p>1）对象：对象是人们要进行研究的任何事物，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。对象具有状态，一个对象用数据值来描述它的状态。对象还有操作，用于改变对象的状态，对象及其操作就是对象的行为。对象实现了数据和操作的结合，使数据和操作封装于对象的统一体中。</p>
<p>2）类：具有相同特性（数据元素）和行为（功能）的对象的抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。类具有属性，它是对象的状态的抽象，用数据结构来描述类的属性。类具有操作，它是对象的行为的抽象，用操作名和实现该操作的方法来描述。
对象和类的关系：</p>
<p>类与对象的关系就如模具和铸件的关系，类的实力化的结果就是对象，而对对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为的对象。</p>
<h3 id="20--new和malloc区别">20 . new和malloc区别<a hidden class="anchor" aria-hidden="true" href="#20--new和malloc区别">#</a></h3>
<p>0.属性
new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</p>
<p>1.参数
使用new操作符申请内存分配时<u>无须指定内存块的大小</u>，编译器会根据类型信息自行计算。而malloc则需要<u>显式地指出所需内存的尺寸</u>。</p>
<p>2.返回类型
new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。
而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
<p>3.分配失败
new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p>
<p>4.自定义类型
new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
<p>5.重载
C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</p>
<p>6.内存区域
new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中</p>
<h3 id="21-内核链表与双向循环链表">21. 内核链表与双向循环链表<a hidden class="anchor" aria-hidden="true" href="#21-内核链表与双向循环链表">#</a></h3>
<p>(内核链表与双向循环链表)[https://blog.csdn.net/liebao_han/article/details/53956609]</p>
<h3 id="22-结构体和类的区别">22. 结构体和类的区别<a hidden class="anchor" aria-hidden="true" href="#22-结构体和类的区别">#</a></h3>
<p>1.结构体是一种值类型，而类是引用类型。值类型用于存储数据的值，引用类型用于存储对实际数据的引用。
那么结构体就是当成值来使用的，类则通过引用来对实际数据操作。</p>
<ol start="2">
<li>结构体使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation)
栈的空间相对较小.但是存储在栈中的数据访问效率相对较高.
堆的空间相对较大.但是存储在堆中的数据的访问效率相对较低.</li>
</ol>
<p>3.类是反映现实事物的一种抽象，而结构体的作用只是一种包含了具体不同类别数据的一种包装，结构体不具备类的继承多态特性</p>
<p>4.结构体赋值是 直接赋值的值. 而对象的指针 赋值的是对象的地址</p>
<p>5.Struct变量使用完之后就自动解除内存分配，Class实例有垃圾回收机制来保证内存的回收处理。</p>
<p>6.结构体的构造函数中，必须为结构体所有字段赋值，类的构造函数无此限制</p>
<p>首先,关于隐式构造函数.我们知道,在1个类中如果我们没有为类写任意的构造函数,那么C++编译器在编译的时候会自动的为这个类生成1个无参数的构造函数.我们将这个构造函数称之为隐式构造函数 但是一旦我们为这个类写了任意的1个构造函数的时候,这个隐式的构造函数就不会自动生成了.在结构体中,就不是这样了,在结构体中隐式的构造函数无论如何都存在。所以程序员不能手动的为结构添加1个无参数的构造函数。</p>
<p>7.结构体中声明的字段无法赋予初值，类可以:</p>
<p>如何选择结构体还是类</p>
<p>1． 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些
2． 结构表示如点、矩形和颜色这样的轻量对象，例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。在此情况下，结构的成本较低。
3． 在表现抽象和多级别的对象层次时，类是最好的选择
4． 大多数情况下该类型只是一些数据时，结构时最佳的选择</p>
<h3 id="23-结构体和联合体区别">23. 结构体和联合体区别<a hidden class="anchor" aria-hidden="true" href="#23-结构体和联合体区别">#</a></h3>
<p>两者最大的区别在于内存利用</p>
<p>一、结构体struct</p>
<pre><code>各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。
</code></pre>
<p>二、联合体union</p>
<p>各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。</p>
<h3 id="24-结构体和枚举">24. 结构体和枚举<a hidden class="anchor" aria-hidden="true" href="#24-结构体和枚举">#</a></h3>
<p>一、结构体</p>
<p>结构体:很像面向对象中的对象，但是结构体没有方法只有属性，一个结构体由不同类型的元素组成，而相较于数组来说，数组只能存储相同类型的元素。结构体占用的空间等于内部各元素占用空间的和，并且元素在内存中的地址（按照元素定义的顺序）是连续的。</p>
<p>注意：结构体不能像面向对象中那样递归调用，自己包含自己，但是可以包含其他类型的结构体。</p>
<p>二、枚举</p>
<p>枚举:和面向对象中一样，枚举都是用来定义一些固定取值的常量,但是C中的枚举中的值是整数，默认按照0递增,也可以在定义枚举的时候赋值，那么后面的元素的值就会以这个元素为第一个元素递增</p>
<h3 id="25--数组和指针的区别与联系">25 . 数组和指针的区别与联系<a hidden class="anchor" aria-hidden="true" href="#25--数组和指针的区别与联系">#</a></h3>
<p>(数组和指针的区别与联系)[https://blog.csdn.net/cherrydreamsover/article/details/81741459]</p>
<h3 id="26--函数指针指针函数">26 . 函数指针&amp;指针函数<a hidden class="anchor" aria-hidden="true" href="#26--函数指针指针函数">#</a></h3>
<p><a href="https://blog.csdn.net/baidu_37973494/article/details/83150266">https://blog.csdn.net/baidu_37973494/article/details/83150266</a></p>
<h3 id="27--const放在函数前后的区别">27 . const放在函数前后的区别<a hidden class="anchor" aria-hidden="true" href="#27--const放在函数前后的区别">#</a></h3>
<p>1、int GetY() const;
2、const int * GetPosition();</p>
<p>对于1
该函数为只读函数，不允许修改其中的数据成员的值。</p>
<p>对于2
修饰的是返回值，表示返回的是指针所指向值是常量</p>
<h3 id="28--goto语句">28 . goto语句<a hidden class="anchor" aria-hidden="true" href="#28--goto语句">#</a></h3>
<p>goto语句也称为无条件转移语句，其一般格式如下： goto 语句标号； 其中语句标号是按标识符规定书写的符号， 放在某一语句行的前面，标号后加冒号(：)。语句标号起标识语句的作用，与goto 语句配合使用。举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">goto</span> <span class="n">label</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;This is the&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="29--extern关键字">29 . extern关键字<a hidden class="anchor" aria-hidden="true" href="#29--extern关键字">#</a></h3>
<p>1、extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。也就是说，在一个文件中定义了变量和函数， 在其他文件中要使用它们， 可以有两种方式：使用头文件，然后声明它们，然后其他文件去包含头文件；在其他文件中直接extern。</p>
<p>2、extern C作用</p>
<p>链接指示符extern C
如果程序员希望调用其他程序设计语言尤其是C 写的函数，那么调用函数时必须告诉编译器使用不同的要求，例如当这样的函数被调用时函数名或参数排列的顺序可能不同，无论是C++函数调用它还是用其他语言写的函数调用它，程序员用链接指示符告诉编译器该函数是用其他的程序设计语言编写的，链接指示符有两种形式既可以是单一语句形式也可以是复合语句形式。
// 单一语句形式的链接指示符
extern &ldquo;C&rdquo; void exit(int);
// 复合语句形式的链接指示符
extern &ldquo;C&rdquo; {
int printf( const char* &hellip; );
int scanf( const char* &hellip; );
}
// 复合语句形式的链接指示符
extern &ldquo;C&rdquo; {
#include <cmath>
}
链接指示符的第一种形式由关键字extern 后跟一个字符串常量以及一个普通的函数，声明构成虽然函数是用另外一种语言编写的但调用它仍然需要类型检查例如编译器会检查传递给函数exit()的实参的类型是否是int 或者能够隐式地转换成int 型，多个函数声明可以用花括号包含在链接指示符复合语句中，这是链接指示符的第二种形式花扩号被用作分割符表示链接指示符应用在哪些声明上在其他意义上该花括号被忽略，所以在花括号中声明的函数名对外是可见的就好像函数是在复合语句外声明的一样，例如在前面的例子中复合语句extern &ldquo;C&quot;表示函数printf()和scanf()是在C 语言中写的，函数因此这个声明的意义就如同printf()和scanf()是在extern &ldquo;C&quot;复合语句外面声明的一样，当复合语句链接指示符的括号中含有#include 时，在头文件中的函数声明都被假定是用链接指示符的程序设计语言所写的，在前面的例子中在头文件<cmath>中声明的函数都是C函数链接指示符不能出现在函数体中下列代码段将会导致编译错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 错误: 链接指示符不能出现在函数内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="kt">double</span> <span class="n">sqrt</span><span class="p">(</span> <span class="kt">double</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">305</span> <span class="err">第七章函数</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">getValue</span><span class="p">();</span> <span class="c1">//ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">(</span> <span class="n">getValue</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="err">如果把链接指示符移到函数体外程序编译将无错误</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="kt">double</span> <span class="n">sqrt</span><span class="p">(</span> <span class="kt">double</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">getValue</span><span class="p">();</span> <span class="c1">//ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">(</span> <span class="n">getValue</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="err">但是把链接指示符放在头文件中更合适，在那里函数声明描述了函数的接口所属，如果我们希望</span><span class="n">C</span><span class="o">++</span><span class="err">函数能够为</span><span class="n">C</span> <span class="err">程序所用又该怎么办呢我们也可以使用</span><span class="k">extern</span> <span class="s">&#34;C&#34;</span><span class="err">链接指示符来使</span><span class="n">C</span><span class="o">++</span><span class="err">函数为</span><span class="n">C</span> <span class="err">程序可用例如。</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 函数calc() 可以被C 程序调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="kt">double</span> <span class="n">calc</span><span class="p">(</span> <span class="kt">double</span> <span class="n">dparm</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="err">如果一个函数在同一文件中不只被声明一次则链接指示符可以出现在每个声明中它，也可以只出现在函数的第一次声明中，在这种情况下第二个及以后的声明都接受第一个声明中链接指示符指定的链接规则例如</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ---- myMath.h ----
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="kt">double</span> <span class="n">calc</span><span class="p">(</span> <span class="kt">double</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ---- myMath.C ----
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在Math.h 中的calc() 的声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;myMath.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 定义了extern &#34;C&#34; calc() 函数
</span></span></span><span class="line"><span class="cl"><span class="c1">// calc() 可以从C 程序中被调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="nf">calc</span><span class="p">(</span> <span class="kt">double</span> <span class="n">dparm</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">在本节中我们只看到为</span><span class="n">C</span> <span class="err">语言提供的链接指示</span><span class="k">extern</span> <span class="s">&#34;C&#34;</span><span class="err">，</span><span class="k">extern</span> <span class="s">&#34;C&#34;</span><span class="err">是惟一被保证由所有</span><span class="n">C</span><span class="o">++</span><span class="err">实现都支持的，每个编译器实现都可以为其环境下常用的语言提供其他链接指示例如</span><span class="k">extern</span> <span class="s">&#34;Ada&#34;</span><span class="err">可以用来声明是用</span><span class="n">Ada</span> <span class="err">语言写的函数，</span><span class="k">extern</span> <span class="s">&#34;FORTRAN&#34;</span><span class="err">用来声明是用</span><span class="n">FORTRAN</span> <span class="err">语言写的函数，等等因为其他的链接指示随着具体实现的不同而不同所以建议读者查看编译器的用户指南以获得其他链接指示符的进一步信息。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>总结 extern “C”
extern “C” 不但具有传统的声明外部变量的功能，还具有告知C++链接器使用C函数规范来链接的功能。 还具有告知C++编译器使用C规范来命名的功能。</p>
<h3 id="30--动态内存管理">30 . 动态内存管理<a hidden class="anchor" aria-hidden="true" href="#30--动态内存管理">#</a></h3>
<p>(动态内存管理)[https://blog.csdn.net/zgege/article/details/82054076]</p>
<h3 id="31-数组链表哈希队列栈数据结构特点各自优点和缺点">31 .数组、链表、哈希、队列、栈数据结构特点，各自优点和缺点<a hidden class="anchor" aria-hidden="true" href="#31-数组链表哈希队列栈数据结构特点各自优点和缺点">#</a></h3>
<p>数组(Array)：
优点：查询快，通过索引直接查找；有序添加，添加速度快，允许重复；
缺点：在中间部位添加、删除比较复杂，大小固定，只能存储一种类型的数据；
如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。</p>
<p>链表(LinkedList)：
优点：有序添加、增删改速度快，对于链表数据结构，增加和删除只要修改元素中的指针就可以了；
缺点：查询慢，如果要访问链表中一个元素，就需要从第一个元素开始查找；
如果应用需要经常插入和删除元素，就应该用链表。</p>
<p>栈(Stack)：
优点：提供后进先出的存储方式，添加速度快，允许重复；
缺点：只能在一头操作数据，存取其他项很慢；</p>
<p>队列(Queue)：
优点：提供先进先出的存储方式，添加速度快，允许重复；
缺点：只能在一头添加，另一头获取，存取其他项很慢；</p>
<p>哈希(Hash)：
特点：散列表，不允许重复；
优点：如果关键字已知则存取速度极快；
缺点：如果不知道关键字则存取很慢，对存储空间使用不充分；</p>
<h3 id="32-友元函数">32. 友元函数<a hidden class="anchor" aria-hidden="true" href="#32-友元函数">#</a></h3>
<pre><code>引入友元函数的原因
    类具有封装、继承、多态、信息隐藏的特性，只有类的成员函数才可以访问类的私有成员，非成员函数只能访问类的公有成员。为了使类的非成员函数访问类的成员，唯一的做法就是将成员定义为public，但这样做会破坏信息隐藏的特性。基于以上原因，引入友元函数解决。
</code></pre>
<p>(友元函数)[https://blog.csdn.net/qq_26337701/article/details/53996104]</p>
<h3 id="33-设计模式之单例模式工厂模式发布订阅模式以及观察者模式">33. 设计模式之单例模式、工厂模式、发布订阅模式以及观察者模式<a hidden class="anchor" aria-hidden="true" href="#33-设计模式之单例模式工厂模式发布订阅模式以及观察者模式">#</a></h3>
<p>(设计模式)[https://blog.csdn.net/m0_37322399/article/details/108515158]</p>
<h3 id="34-构造函数">34. 构造函数：<a hidden class="anchor" aria-hidden="true" href="#34-构造函数">#</a></h3>
<blockquote>
<p>什么是构造函数？</p>
</blockquote>
<p>通俗的讲，在类中，函数名和类名相同的函数称为构造函数。它的作用是在建立一个对象时，做某些初始化的工作（例如对数据赋予初值）。C++允许同名函数，也就允许在一个类中有多个构造函数。如果一个都没有，编译器将为该类产生一个默认的构造函数。</p>
<p>构造函数上惟一的语法限制是它不能指定返回类型，甚至void 也不行。</p>
<p>不带参数的构造函数：一般形式为 类名 对象名(){函数体}</p>
<p>带参数的构造函数：不带参数的构造函数，只能以固定不变的值初始化对象。带参数构造函数的初始化要灵活的多，通过传递给构造函数的参数，可以赋予对象不同的初始值。一般形式为：构造函数名（形参表）；</p>
<p>创建对象使用时：类名 对象名（实参表）；</p>
<p>构造函数参数的初始值：构造函数的参数可以有缺省值。当定义对象时，如果不给出参数，就自动把相应的缺省参数值赋给对象。一般形式为：
构造函数名（参数=缺省值，参数=缺省值，……）;
析构函数：</p>
<p>当一个类的对象离开作用域时，析构函数将被调用(系统自动调用)。析构函数的名字和类名一样，不过要在前面加上 ~ 。对一个类来说，只能允许一个析构函数，析构函数不能有参数，并且也没有返回值。析构函数的作用是完成一个清理工作，如释放从堆中分配的内存。</p>
<p>一个类中可以有多个构造函数，但析构函数只能有一个。对象被析构的顺序，与其建立时的顺序相反，即后构造的对象先析构。
1、概念不同：</p>
<p>析构函数：对象所在的函数已调用完毕时，系统自动执行析构函数。</p>
<p>构造函数：是一种特殊的方法。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。
2、作用不同：</p>
<p>析构函数：析构函数被调用。</p>
<hr>
<p>构造函数：为对象成员变量赋初始值
3、目的不同：</p>
<p>析构函数：”清理善后” 的工作</p>
<p>构造函数：主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p>
<h3 id="35-c模板">35. C++模板<a hidden class="anchor" aria-hidden="true" href="#35-c模板">#</a></h3>
<p><a href="https://blog.csdn.net/zhaizhaizhaiaaa/article/details/104091658">https://blog.csdn.net/zhaizhaizhaiaaa/article/details/104091658</a></p>
<h3 id="36-c-stl">36. C++ STL<a hidden class="anchor" aria-hidden="true" href="#36-c-stl">#</a></h3>
<p><a href="https://www.cnblogs.com/shiyangxt/archive/2008/09/11/1289493.html">https://www.cnblogs.com/shiyangxt/archive/2008/09/11/1289493.html</a></p>
<p>ref: <a href="https://blog.csdn.net/qq_52621551/article/details/122960158">https://blog.csdn.net/qq_52621551/article/details/122960158</a></p>
<h2 id="c-八股文">c++ 八股文<a hidden class="anchor" aria-hidden="true" href="#c-八股文">#</a></h2>
<h3 id="关键字与运算符">关键字与运算符<a hidden class="anchor" aria-hidden="true" href="#关键字与运算符">#</a></h3>
<h4 id="1-指针与引">1. 指针与引⽤<a hidden class="anchor" aria-hidden="true" href="#1-指针与引">#</a></h4>
<p>指针：存放某个对象的地址，其本⾝就是变量（命了名的对象），本⾝就有地址，所以可以有指向指针的指针；可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变 (地址可变，地址存储的值也可变)</p>
<p>引⽤：就是变量的别名，从⼀⽽终，不可变，必须初始化， 不存在指向空值的引⽤，但是存在指向空值的指针</p>
<h4 id="2-const-关键字">2. const 关键字<a hidden class="anchor" aria-hidden="true" href="#2-const-关键字">#</a></h4>
<p>const的作⽤：被它修饰的值不能改变，是只读变量。必须在定义的时候就给它赋初值。</p>
<p>顶层const: 表示指针本身是个常量
底层const: 表示指针所指的对象是一个常量</p>
<p>2.1 常量指针（<strong>底层const</strong>）（<strong>指针指的对象</strong>不可改变）</p>
<p>常量指针：是指定义了⼀个指针，这个指针指向⼀个只读的对象，不能通过常量指针来改变这个对象的值。常量指针强调的是指针对其所指对象的不可改变性。
特点：靠近变量名
形式:</p>
<ul>
<li>const 数据类型 *指针变量 = 变量名</li>
<li>数据类型 const *指针变量 = 变量名</li>
<li>举例:
<ul>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  int temp = 10;
</span></span><span class="line"><span class="cl">  const int* a = &amp;temp;
</span></span><span class="line"><span class="cl">  int const *a = &amp;temp;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<p>2.2 指针常量（<strong>顶层const</strong>）(<strong>指针</strong>不能改变)
指针常量：指针常量是指定义了⼀个指针，这个指针的值只能在定义时初始化，其他地⽅不能改变。指针常量强调的是指针的不可改变性。
特点: 靠近变量类型
形式: 数据类型 * const 指针变量=变量名</p>
<ul>
<li>实例:
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">temp</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="3-define-和-typedef的区别">3. define 和 typedef的区别<a hidden class="anchor" aria-hidden="true" href="#3-define-和-typedef的区别">#</a></h4>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="https://jianye0428.github.io/en/posts/notes/gpu_compute/cuda_1/">
    <span class="title"><i class="fas fa-angle-double-left"></i> Prev Page</span>
    <br>
    <span>CUDA_1</span>
  </a>
  <a class="next" href="https://jianye0428.github.io/en/posts/notes/c&#43;&#43;/2022-11-05_c&#43;&#43;_primer/">
    <span class="title">Next Page <i class="fas fa-angle-double-right"></i></span>
    <br>
    <span>C&#43;&#43;_PRIMER Notes</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;_basics on twitter"
        href="https://twitter.com/intent/tweet/?text=C%2b%2b_basics&amp;url=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fc%2b%2b%2f2022-11-10_c%2b%2b_basics%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;_basics on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fc%2b%2b%2f2022-11-10_c%2b%2b_basics%2f&amp;title=C%2b%2b_basics&amp;summary=C%2b%2b_basics&amp;source=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fc%2b%2b%2f2022-11-10_c%2b%2b_basics%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;_basics on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fc%2b%2b%2f2022-11-10_c%2b%2b_basics%2f&title=C%2b%2b_basics">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;_basics on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fc%2b%2b%2f2022-11-10_c%2b%2b_basics%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;_basics on whatsapp"
        href="https://api.whatsapp.com/send?text=C%2b%2b_basics%20-%20https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fc%2b%2b%2f2022-11-10_c%2b%2b_basics%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;_basics on telegram"
        href="https://telegram.me/share/url?text=C%2b%2b_basics&amp;url=https%3a%2f%2fjianye0428.github.io%2fen%2fposts%2fnotes%2fc%2b%2b%2f2022-11-10_c%2b%2b_basics%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>




<footer class="tc-container" id="comment">
    <div class="tc-title"><p class="c-title">Discussion</p></div>
    <div id="tcomments"></div>
</footer>
<script crossorigin="anonymous" src="/js/twikoo.min.b16100b7cf8a61759eab076a122482054e083087aad37c3be1fe2e293934dc34.js" integrity="sha256-sWEAt8&#43;KYXWeqwdqEiSCBU4IMIeq03w74f4uKTk03DQ="></script>
<script>
    twikoo.init({
        envId: 'https://my-repository-pink.vercel.app/',
        el: '#tcomments',
        region: 'ap-shanghai', 
        
        lang: 'zh-CN', 
    });
</script>

</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
